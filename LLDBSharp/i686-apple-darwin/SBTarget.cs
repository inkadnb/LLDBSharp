//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace LLDB
{
    public unsafe partial class Target : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTargetC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTargetC2ERKS0_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr rhs);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTargetD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK4lldb8SBTarget7IsValidEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsValid_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget18EventIsTargetEventERKNS_7SBEventE")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool EventIsTargetEvent_0(global::System.IntPtr @event);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget18GetTargetFromEventERKNS_7SBEventE")]
            internal static extern void GetTargetFromEvent_0(global::System.IntPtr @return, global::System.IntPtr @event);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget22GetNumModulesFromEventERKNS_7SBEventE")]
            internal static extern uint GetNumModulesFromEvent_0(global::System.IntPtr @event);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget25GetModuleAtIndexFromEventEjRKNS_7SBEventE")]
            internal static extern void GetModuleAtIndexFromEvent_0(global::System.IntPtr @return, uint idx, global::System.IntPtr @event);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget10GetProcessEv")]
            internal static extern void GetProcess_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget11GetPlatformEv")]
            internal static extern void GetPlatform_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget7InstallEv")]
            internal static extern void Install_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget6LaunchERNS_10SBListenerEPPKcS5_S4_S4_S4_S4_jbRNS_7SBErrorE")]
            internal static extern void Launch_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr listener, sbyte** argv, sbyte** envp, global::System.IntPtr stdin_path, global::System.IntPtr stdout_path, global::System.IntPtr stderr_path, global::System.IntPtr working_directory, uint launch_flags, bool stop_at_entry, global::System.IntPtr error);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget8LoadCoreEPKc")]
            internal static extern void LoadCore_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr core_file);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget12LaunchSimpleEPPKcS3_S2_")]
            internal static extern void LaunchSimple_0(global::System.IntPtr @return, global::System.IntPtr instance, sbyte** argv, sbyte** envp, global::System.IntPtr working_directory);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget6LaunchERNS_12SBLaunchInfoERNS_7SBErrorE")]
            internal static extern void Launch_1(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr launch_info, global::System.IntPtr error);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget6AttachERNS_12SBAttachInfoERNS_7SBErrorE")]
            internal static extern void Attach_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr attach_info, global::System.IntPtr error);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget21AttachToProcessWithIDERNS_10SBListenerEyRNS_7SBErrorE")]
            internal static extern void AttachToProcessWithID_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr listener, ulong pid, global::System.IntPtr error);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget21AttachToProcessWithIDERNS_10SBListenerEiRNS_7SBErrorE")]
            internal static extern void AttachToProcessWithID_1(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr listener, int pid, global::System.IntPtr error);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget23AttachToProcessWithNameERNS_10SBListenerEPKcbRNS_7SBErrorE")]
            internal static extern void AttachToProcessWithName_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr listener, global::System.IntPtr name, bool wait_for, global::System.IntPtr error);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget13ConnectRemoteERNS_10SBListenerEPKcS4_RNS_7SBErrorE")]
            internal static extern void ConnectRemote_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr listener, global::System.IntPtr url, global::System.IntPtr plugin_name, global::System.IntPtr error);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget13GetExecutableEv")]
            internal static extern void GetExecutable_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget9AddModuleERNS_8SBModuleE")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool AddModule_0(global::System.IntPtr instance, global::System.IntPtr module);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget9AddModuleEPKcS2_S2_")]
            internal static extern void AddModule_1(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr path, global::System.IntPtr triple, global::System.IntPtr uuid);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget9AddModuleEPKcS2_S2_S2_")]
            internal static extern void AddModule_2(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr path, global::System.IntPtr triple, global::System.IntPtr uuid_cstr, global::System.IntPtr symfile);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget9AddModuleERKNS_12SBModuleSpecE")]
            internal static extern void AddModule_3(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr module_spec);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget16GetModuleAtIndexEj")]
            internal static extern void GetModuleAtIndex_0(global::System.IntPtr @return, global::System.IntPtr instance, uint idx);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget12RemoveModuleENS_8SBModuleE")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool RemoveModule_0(global::System.IntPtr instance, LLDB.Module.Internal module);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK4lldb8SBTarget11GetDebuggerEv")]
            internal static extern void GetDebugger_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget10FindModuleERKNS_10SBFileSpecE")]
            internal static extern void FindModule_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr file_spec);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget21SetSectionLoadAddressENS_9SBSectionEy")]
            internal static extern void SetSectionLoadAddress_0(global::System.IntPtr @return, global::System.IntPtr instance, LLDB.Section.Internal section, ulong section_base_addr);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget23ClearSectionLoadAddressENS_9SBSectionE")]
            internal static extern void ClearSectionLoadAddress_0(global::System.IntPtr @return, global::System.IntPtr instance, LLDB.Section.Internal section);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget20SetModuleLoadAddressENS_8SBModuleEx")]
            internal static extern void SetModuleLoadAddress_0(global::System.IntPtr @return, global::System.IntPtr instance, LLDB.Module.Internal module, long sections_offset);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget22ClearModuleLoadAddressENS_8SBModuleE")]
            internal static extern void ClearModuleLoadAddress_0(global::System.IntPtr @return, global::System.IntPtr instance, LLDB.Module.Internal module);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget13FindFunctionsEPKcj")]
            internal static extern void FindFunctions_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr name, uint name_type_mask);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget19FindGlobalVariablesEPKcj")]
            internal static extern void FindGlobalVariables_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr name, uint max_matches);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget23FindFirstGlobalVariableEPKc")]
            internal static extern void FindFirstGlobalVariable_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget19FindGlobalVariablesEPKcjNS_9MatchTypeE")]
            internal static extern void FindGlobalVariables_1(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr name, uint max_matches, LLDB.MatchType matchtype);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget19FindGlobalFunctionsEPKcjNS_9MatchTypeE")]
            internal static extern void FindGlobalFunctions_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr name, uint max_matches, LLDB.MatchType matchtype);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget5ClearEv")]
            internal static extern void Clear_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget18ResolveFileAddressEy")]
            internal static extern void ResolveFileAddress_0(global::System.IntPtr @return, global::System.IntPtr instance, ulong file_addr);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget18ResolveLoadAddressEy")]
            internal static extern void ResolveLoadAddress_0(global::System.IntPtr @return, global::System.IntPtr instance, ulong vm_addr);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget22ResolvePastLoadAddressEjy")]
            internal static extern void ResolvePastLoadAddress_0(global::System.IntPtr @return, global::System.IntPtr instance, uint stop_id, ulong vm_addr);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget30ResolveSymbolContextForAddressERKNS_9SBAddressEj")]
            internal static extern void ResolveSymbolContextForAddress_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr addr, uint resolve_scope);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget10ReadMemoryENS_9SBAddressEPvmRNS_7SBErrorE")]
            internal static extern uint ReadMemory_0(global::System.IntPtr instance, LLDB.Address.Internal addr, global::System.IntPtr buf, uint size, global::System.IntPtr error);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget26BreakpointCreateByLocationEPKcj")]
            internal static extern void BreakpointCreateByLocation_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr file, uint line);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget26BreakpointCreateByLocationERKNS_10SBFileSpecEj")]
            internal static extern void BreakpointCreateByLocation_1(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr file_spec, uint line);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget26BreakpointCreateByLocationERKNS_10SBFileSpecEjy")]
            internal static extern void BreakpointCreateByLocation_2(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr file_spec, uint line, ulong offset);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget22BreakpointCreateByNameEPKcS2_")]
            internal static extern void BreakpointCreateByName_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr symbol_name, global::System.IntPtr module_name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget22BreakpointCreateByNameEPKcRKNS_14SBFileSpecListES5_")]
            internal static extern void BreakpointCreateByName_1(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr symbol_name, global::System.IntPtr module_list, global::System.IntPtr comp_unit_list);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget22BreakpointCreateByNameEPKcjRKNS_14SBFileSpecListES5_")]
            internal static extern void BreakpointCreateByName_2(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr symbol_name, uint name_type_mask, global::System.IntPtr module_list, global::System.IntPtr comp_unit_list);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget22BreakpointCreateByNameEPKcjNS_12LanguageTypeERKNS_14SBFileSpecListES6_")]
            internal static extern void BreakpointCreateByName_3(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr symbol_name, uint name_type_mask, LLDB.LanguageType symbol_language, global::System.IntPtr module_list, global::System.IntPtr comp_unit_list);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget23BreakpointCreateByRegexEPKcS2_")]
            internal static extern void BreakpointCreateByRegex_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr symbol_name_regex, global::System.IntPtr module_name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget23BreakpointCreateByRegexEPKcRKNS_14SBFileSpecListES5_")]
            internal static extern void BreakpointCreateByRegex_1(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr symbol_name_regex, global::System.IntPtr module_list, global::System.IntPtr comp_unit_list);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget23BreakpointCreateByRegexEPKcNS_12LanguageTypeERKNS_14SBFileSpecListES6_")]
            internal static extern void BreakpointCreateByRegex_2(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr symbol_name_regex, LLDB.LanguageType symbol_language, global::System.IntPtr module_list, global::System.IntPtr comp_unit_list);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget29BreakpointCreateBySourceRegexEPKcRKNS_10SBFileSpecES2_")]
            internal static extern void BreakpointCreateBySourceRegex_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr source_regex, global::System.IntPtr source_file, global::System.IntPtr module_name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget29BreakpointCreateBySourceRegexEPKcRKNS_14SBFileSpecListES5_")]
            internal static extern void BreakpointCreateBySourceRegex_1(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr source_regex, global::System.IntPtr module_list, global::System.IntPtr source_file);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget28BreakpointCreateForExceptionENS_12LanguageTypeEbb")]
            internal static extern void BreakpointCreateForException_0(global::System.IntPtr @return, global::System.IntPtr instance, LLDB.LanguageType language, bool catch_bp, bool throw_bp);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget25BreakpointCreateByAddressEy")]
            internal static extern void BreakpointCreateByAddress_0(global::System.IntPtr @return, global::System.IntPtr instance, ulong address);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget27BreakpointCreateBySBAddressERNS_9SBAddressE")]
            internal static extern void BreakpointCreateBySBAddress_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr address);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK4lldb8SBTarget20GetBreakpointAtIndexEj")]
            internal static extern void GetBreakpointAtIndex_0(global::System.IntPtr @return, global::System.IntPtr instance, uint idx);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget16BreakpointDeleteEi")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool BreakpointDelete_0(global::System.IntPtr instance, int break_id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget18FindBreakpointByIDEi")]
            internal static extern void FindBreakpointByID_0(global::System.IntPtr @return, global::System.IntPtr instance, int break_id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget20EnableAllBreakpointsEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool EnableAllBreakpoints_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget21DisableAllBreakpointsEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool DisableAllBreakpoints_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget20DeleteAllBreakpointsEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool DeleteAllBreakpoints_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK4lldb8SBTarget20GetWatchpointAtIndexEj")]
            internal static extern void GetWatchpointAtIndex_0(global::System.IntPtr @return, global::System.IntPtr instance, uint idx);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget16DeleteWatchpointEi")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool DeleteWatchpoint_0(global::System.IntPtr instance, int watch_id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget18FindWatchpointByIDEi")]
            internal static extern void FindWatchpointByID_0(global::System.IntPtr @return, global::System.IntPtr instance, int watch_id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget12WatchAddressEymbbRNS_7SBErrorE")]
            internal static extern void WatchAddress_0(global::System.IntPtr @return, global::System.IntPtr instance, ulong addr, uint size, bool read, bool write, global::System.IntPtr error);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget20EnableAllWatchpointsEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool EnableAllWatchpoints_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget21DisableAllWatchpointsEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool DisableAllWatchpoints_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget20DeleteAllWatchpointsEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool DeleteAllWatchpoints_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK4lldb8SBTarget14GetBroadcasterEv")]
            internal static extern void GetBroadcaster_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget13FindFirstTypeEPKc")]
            internal static extern void FindFirstType_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget9FindTypesEPKc")]
            internal static extern void FindTypes_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget12GetBasicTypeENS_9BasicTypeE")]
            internal static extern void GetBasicType_0(global::System.IntPtr @return, global::System.IntPtr instance, LLDB.BasicType type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget22CreateValueFromAddressEPKcNS_9SBAddressENS_6SBTypeE")]
            internal static extern void CreateValueFromAddress_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr name, LLDB.Address.Internal addr, LLDB.Type.Internal type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget19CreateValueFromDataEPKcNS_6SBDataENS_6SBTypeE")]
            internal static extern void CreateValueFromData_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr name, LLDB.Data.Internal data, LLDB.Type.Internal type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget25CreateValueFromExpressionEPKcS2_")]
            internal static extern void CreateValueFromExpression_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr name, global::System.IntPtr expr);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget16GetSourceManagerEv")]
            internal static extern void GetSourceManager_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget16ReadInstructionsENS_9SBAddressEj")]
            internal static extern void ReadInstructions_0(global::System.IntPtr @return, global::System.IntPtr instance, LLDB.Address.Internal base_addr, uint count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget16ReadInstructionsENS_9SBAddressEjPKc")]
            internal static extern void ReadInstructions_1(global::System.IntPtr @return, global::System.IntPtr instance, LLDB.Address.Internal base_addr, uint count, global::System.IntPtr flavor_string);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget15GetInstructionsENS_9SBAddressEPKvm")]
            internal static extern void GetInstructions_0(global::System.IntPtr @return, global::System.IntPtr instance, LLDB.Address.Internal base_addr, global::System.IntPtr buf, uint size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget25GetInstructionsWithFlavorENS_9SBAddressEPKcPKvm")]
            internal static extern void GetInstructionsWithFlavor_0(global::System.IntPtr @return, global::System.IntPtr instance, LLDB.Address.Internal base_addr, global::System.IntPtr flavor_string, global::System.IntPtr buf, uint size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget15GetInstructionsEyPKvm")]
            internal static extern void GetInstructions_1(global::System.IntPtr @return, global::System.IntPtr instance, ulong base_addr, global::System.IntPtr buf, uint size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget25GetInstructionsWithFlavorEyPKcPKvm")]
            internal static extern void GetInstructionsWithFlavor_1(global::System.IntPtr @return, global::System.IntPtr instance, ulong base_addr, global::System.IntPtr flavor_string, global::System.IntPtr buf, uint size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget11FindSymbolsEPKcNS_10SymbolTypeE")]
            internal static extern void FindSymbols_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr name, LLDB.SymbolType type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK4lldb8SBTargeteqERKS0_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr rhs);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK4lldb8SBTargetneERKS0_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual_0(global::System.IntPtr instance, global::System.IntPtr rhs);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget14GetDescriptionERNS_8SBStreamENS_16DescriptionLevelE")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool GetDescription_0(global::System.IntPtr instance, global::System.IntPtr description, LLDB.DescriptionLevel description_level);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget18EvaluateExpressionEPKc")]
            internal static extern void EvaluateExpression_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr expr);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget18EvaluateExpressionEPKcRKNS_19SBExpressionOptionsE")]
            internal static extern void EvaluateExpression_1(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr expr, global::System.IntPtr options);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK4lldb8SBTarget13GetLaunchInfoEv")]
            internal static extern void GetLaunchInfo_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget23GetBroadcasterClassNameEv")]
            internal static extern global::System.IntPtr GetBroadcasterClassName_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK4lldb8SBTarget13GetNumModulesEv")]
            internal static extern uint GetNumModules_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget12GetByteOrderEv")]
            internal static extern LLDB.ByteOrder GetByteOrder_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget18GetAddressByteSizeEv")]
            internal static extern uint GetAddressByteSize_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget9GetTripleEv")]
            internal static extern global::System.IntPtr GetTriple_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget15GetDataByteSizeEv")]
            internal static extern uint GetDataByteSize_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget15GetCodeByteSizeEv")]
            internal static extern uint GetCodeByteSize_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK4lldb8SBTarget17GetNumBreakpointsEv")]
            internal static extern uint GetNumBreakpoints_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK4lldb8SBTarget17GetNumWatchpointsEv")]
            internal static extern uint GetNumWatchpoints_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget19GetStackRedZoneSizeEv")]
            internal static extern ulong GetStackRedZoneSize_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb8SBTarget13SetLaunchInfoERKNS_12SBLaunchInfoE")]
            internal static extern void SetLaunchInfo_0(global::System.IntPtr instance, global::System.IntPtr launch_info);
        }

        [Flags]
        public enum BroadcastBit : uint
        {
            BroadcastBitBreakpointChanged = 1,
            BroadcastBitModulesLoaded = 2,
            BroadcastBitModulesUnloaded = 4,
            BroadcastBitWatchpointChanged = 8,
            BroadcastBitSymbolsLoaded = 16
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Target> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Target>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        public static Target __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new Target(native.ToPointer(), skipVTables);
        }

        public static Target __CreateInstance(Target.Internal native, bool skipVTables = false)
        {
            return new Target(native, skipVTables);
        }

        private static void* __CopyValue(Target.Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            LLDB.Target.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Target(Target.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Target(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Target()
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            Internal.ctor_0((__Instance + __PointerAdjustment));
        }

        public Target(LLDB.Target rhs)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(rhs, null))
                throw new global::System.ArgumentNullException("rhs", "Cannot be null because it is a C++ reference (&).");
            var arg0 = rhs.__Instance;
            Internal.cctor_1((__Instance + __PointerAdjustment), arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        protected virtual void Dispose(bool disposing)
        {
            LLDB.Target __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            Internal.dtor_0((__Instance + __PointerAdjustment));
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public bool IsValid()
        {
            var __ret = Internal.IsValid_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public LLDB.Process GetProcess()
        {
            var __ret = new LLDB.Process.Internal();
            Internal.GetProcess_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment));
            return LLDB.Process.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Return the platform object associated with the target.</para>
        /// </summary>
        /// <remarks>
        /// <para>After return, the platform object should be checked for</para>
        /// <para>validity.</para>
        /// </remarks>
        /// <returns>
        /// <para>A platform object.</para>
        /// </returns>
        public LLDB.Platform GetPlatform()
        {
            var __ret = new LLDB.Platform.Internal();
            Internal.GetPlatform_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment));
            return LLDB.Platform.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Install any binaries that need to be installed.</para>
        /// </summary>
        /// <remarks>
        /// <para>This function does nothing when debugging on the host system.</para>
        /// <para>When connected to remote platforms, the target's main executable</para>
        /// <para>and any modules that have their remote install path set will be</para>
        /// <para>installed on the remote platform. If the main executable doesn't</para>
        /// <para>have an install location set, it will be installed in the remote</para>
        /// <para>platform's working directory.</para>
        /// </remarks>
        /// <returns>
        /// <para>An error describing anything that went wrong during</para>
        /// <para>installation.</para>
        /// </returns>
        public LLDB.Error Install()
        {
            var __ret = new LLDB.Error.Internal();
            Internal.Install_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment));
            return LLDB.Error.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Launch a new process.</para>
        /// </summary>
        /// <remarks>
        /// <para>Launch a new process by spawning a new process using the</para>
        /// <para>target object's executable module's file as the file to launch.</para>
        /// <para>Arguments are given in </para>
        /// <para>and the environment variables</para>
        /// <para>are in </para>
        /// <para>Standard input and output files can be</para>
        /// <para>optionally re-directed to </para>
        /// <para> </para>
        /// <para>and</para>
        /// </remarks>
        /// <param name="listener">
        /// <para>An optional listener that will receive all process events.</para>
        /// <para>If</para>
        /// <para>is valid then</para>
        /// <para>will listen to all</para>
        /// <para>process events. If not valid, then this target's debugger</para>
        /// <para>(SBTarget::GetDebugger()) will listen to all process events.</para>
        /// </param>
        /// <param name="argv">
        /// <para>The argument array.</para>
        /// </param>
        /// <param name="envp">
        /// <para>The environment array.</para>
        /// </param>
        /// <param name="launch_flags">
        /// <para>Flags to modify the launch (</para>
        /// </param>
        /// <param name="stdin_path">
        /// <para>The path to use when re-directing the STDIN of the new</para>
        /// <para>process. If all stdXX_path arguments are nullptr, a pseudo</para>
        /// <para>terminal will be used.</para>
        /// </param>
        /// <param name="stdout_path">
        /// <para>The path to use when re-directing the STDOUT of the new</para>
        /// <para>process. If all stdXX_path arguments are nullptr, a pseudo</para>
        /// <para>terminal will be used.</para>
        /// </param>
        /// <param name="stderr_path">
        /// <para>The path to use when re-directing the STDERR of the new</para>
        /// <para>process. If all stdXX_path arguments are nullptr, a pseudo</para>
        /// <para>terminal will be used.</para>
        /// </param>
        /// <param name="working_directory">
        /// <para>The working directory to have the child process run in</para>
        /// </param>
        /// <param name="launch_flags">
        /// <para>Some launch options specified by logical OR'ing</para>
        /// <para>lldb::LaunchFlags enumeration values together.</para>
        /// </param>
        /// <param name="stop_at_entry">
        /// <para>If false do not stop the inferior at the entry point.</para>
        /// </param>
        /// <param name="error">
        /// <para>An error object. Contains the reason if there is some failure.</para>
        /// </param>
        /// <returns>
        /// <para>A process object for the newly created process.</para>
        /// </returns>
        public LLDB.Process Launch(LLDB.Listener listener, sbyte** argv, sbyte** envp, string stdin_path, string stdout_path, string stderr_path, string working_directory, uint launch_flags, bool stop_at_entry, out LLDB.Error error)
        {
            if (ReferenceEquals(listener, null))
                throw new global::System.ArgumentNullException("listener", "Cannot be null because it is a C++ reference (&).");
            var arg0 = listener.__Instance;
            var arg1 = argv;
            var arg2 = envp;
            var arg3 = Marshal.StringToHGlobalAnsi(stdin_path);
            var arg4 = Marshal.StringToHGlobalAnsi(stdout_path);
            var arg5 = Marshal.StringToHGlobalAnsi(stderr_path);
            var arg6 = Marshal.StringToHGlobalAnsi(working_directory);
            error = new LLDB.Error();
            if (ReferenceEquals(error, null))
                throw new global::System.ArgumentNullException("error", "Cannot be null because it is a C++ reference (&).");
            var arg9 = error.__Instance;
            var __ret = new LLDB.Process.Internal();
            Internal.Launch_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment), arg0, arg1, arg2, arg3, arg4, arg5, arg6, launch_flags, stop_at_entry, arg9);
            LLDB.Error __result0;
            if (arg9 == IntPtr.Zero) __result0 = null;
            else if (LLDB.Error.NativeToManagedMap.ContainsKey(arg9))
                __result0 = (LLDB.Error) LLDB.Error.NativeToManagedMap[arg9];
            else __result0 = LLDB.Error.__CreateInstance(arg9);
            error = __result0;
            Marshal.FreeHGlobal(arg3);
            Marshal.FreeHGlobal(arg4);
            Marshal.FreeHGlobal(arg5);
            Marshal.FreeHGlobal(arg6);
            return LLDB.Process.__CreateInstance(__ret);
        }

        public LLDB.Process LoadCore(string core_file)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(core_file);
            var __ret = new LLDB.Process.Internal();
            Internal.LoadCore_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment), arg0);
            Marshal.FreeHGlobal(arg0);
            return LLDB.Process.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Launch a new process with sensible defaults.</para>
        /// </summary>
        /// <param name="argv">
        /// <para>The argument array.</para>
        /// </param>
        /// <param name="envp">
        /// <para>The environment array.</para>
        /// </param>
        /// <param name="working_directory">
        /// <para>The working directory to have the child process run in</para>
        /// <para>Default: listener</para>
        /// <para>Set to the target's debugger (SBTarget::GetDebugger())</para>
        /// <para>Default: launch_flags</para>
        /// <para>Empty launch flags</para>
        /// <para>Default: stdin_path</para>
        /// <para>Default: stdout_path</para>
        /// <para>Default: stderr_path</para>
        /// <para>A pseudo terminal will be used.</para>
        /// </param>
        /// <returns>
        /// <para>A process object for the newly created process.</para>
        /// </returns>
        public LLDB.Process LaunchSimple(sbyte** argv, sbyte** envp, string working_directory)
        {
            var arg0 = argv;
            var arg1 = envp;
            var arg2 = Marshal.StringToHGlobalAnsi(working_directory);
            var __ret = new LLDB.Process.Internal();
            Internal.LaunchSimple_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment), arg0, arg1, arg2);
            Marshal.FreeHGlobal(arg2);
            return LLDB.Process.__CreateInstance(__ret);
        }

        public LLDB.Process Launch(LLDB.LaunchInfo launch_info, LLDB.Error error)
        {
            if (ReferenceEquals(launch_info, null))
                throw new global::System.ArgumentNullException("launch_info", "Cannot be null because it is a C++ reference (&).");
            var arg0 = launch_info.__Instance;
            if (ReferenceEquals(error, null))
                throw new global::System.ArgumentNullException("error", "Cannot be null because it is a C++ reference (&).");
            var arg1 = error.__Instance;
            var __ret = new LLDB.Process.Internal();
            Internal.Launch_1(new IntPtr(&__ret), (__Instance + __PointerAdjustment), arg0, arg1);
            return LLDB.Process.__CreateInstance(__ret);
        }

        public LLDB.Process Attach(LLDB.AttachInfo attach_info, LLDB.Error error)
        {
            if (ReferenceEquals(attach_info, null))
                throw new global::System.ArgumentNullException("attach_info", "Cannot be null because it is a C++ reference (&).");
            var arg0 = attach_info.__Instance;
            if (ReferenceEquals(error, null))
                throw new global::System.ArgumentNullException("error", "Cannot be null because it is a C++ reference (&).");
            var arg1 = error.__Instance;
            var __ret = new LLDB.Process.Internal();
            Internal.Attach_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment), arg0, arg1);
            return LLDB.Process.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Attach to process with pid.</para>
        /// </summary>
        /// <param name="listener">
        /// <para>An optional listener that will receive all process events.</para>
        /// <para>If</para>
        /// <para>is valid then</para>
        /// <para>will listen to all</para>
        /// <para>process events. If not valid, then this target's debugger</para>
        /// <para>(SBTarget::GetDebugger()) will listen to all process events.</para>
        /// </param>
        /// <param name="pid">
        /// <para>The process ID to attach to.</para>
        /// </param>
        /// <param name="error">
        /// <para>An error explaining what went wrong if attach fails.</para>
        /// </param>
        /// <returns>
        /// <para>A process object for the attached process.</para>
        /// </returns>
        public LLDB.Process AttachToProcessWithID(LLDB.Listener listener, ulong pid, LLDB.Error error)
        {
            if (ReferenceEquals(listener, null))
                throw new global::System.ArgumentNullException("listener", "Cannot be null because it is a C++ reference (&).");
            var arg0 = listener.__Instance;
            if (ReferenceEquals(error, null))
                throw new global::System.ArgumentNullException("error", "Cannot be null because it is a C++ reference (&).");
            var arg2 = error.__Instance;
            var __ret = new LLDB.Process.Internal();
            Internal.AttachToProcessWithID_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment), arg0, pid, arg2);
            return LLDB.Process.__CreateInstance(__ret);
        }

        public LLDB.Process AttachToProcessWithID(LLDB.Listener listener, int pid, LLDB.Error error)
        {
            if (ReferenceEquals(listener, null))
                throw new global::System.ArgumentNullException("listener", "Cannot be null because it is a C++ reference (&).");
            var arg0 = listener.__Instance;
            if (ReferenceEquals(error, null))
                throw new global::System.ArgumentNullException("error", "Cannot be null because it is a C++ reference (&).");
            var arg2 = error.__Instance;
            var __ret = new LLDB.Process.Internal();
            Internal.AttachToProcessWithID_1(new IntPtr(&__ret), (__Instance + __PointerAdjustment), arg0, pid, arg2);
            return LLDB.Process.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Attach to process with name.</para>
        /// </summary>
        /// <param name="listener">
        /// <para>An optional listener that will receive all process events.</para>
        /// <para>If</para>
        /// <para>is valid then</para>
        /// <para>will listen to all</para>
        /// <para>process events. If not valid, then this target's debugger</para>
        /// <para>(SBTarget::GetDebugger()) will listen to all process events.</para>
        /// </param>
        /// <param name="name">
        /// <para>Basename of process to attach to.</para>
        /// </param>
        /// <param name="wait_for">
        /// <para>If true wait for a new instance of 'name' to be launched.</para>
        /// </param>
        /// <param name="error">
        /// <para>An error explaining what went wrong if attach fails.</para>
        /// </param>
        /// <returns>
        /// <para>A process object for the attached process.</para>
        /// </returns>
        public LLDB.Process AttachToProcessWithName(LLDB.Listener listener, string name, bool wait_for, LLDB.Error error)
        {
            if (ReferenceEquals(listener, null))
                throw new global::System.ArgumentNullException("listener", "Cannot be null because it is a C++ reference (&).");
            var arg0 = listener.__Instance;
            var arg1 = Marshal.StringToHGlobalAnsi(name);
            if (ReferenceEquals(error, null))
                throw new global::System.ArgumentNullException("error", "Cannot be null because it is a C++ reference (&).");
            var arg3 = error.__Instance;
            var __ret = new LLDB.Process.Internal();
            Internal.AttachToProcessWithName_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment), arg0, arg1, wait_for, arg3);
            Marshal.FreeHGlobal(arg1);
            return LLDB.Process.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Connect to a remote debug server with url.</para>
        /// </summary>
        /// <param name="listener">
        /// <para>An optional listener that will receive all process events.</para>
        /// <para>If</para>
        /// <para>is valid then</para>
        /// <para>will listen to all</para>
        /// <para>process events. If not valid, then this target's debugger</para>
        /// <para>(SBTarget::GetDebugger()) will listen to all process events.</para>
        /// </param>
        /// <param name="url">
        /// <para>The url to connect to, e.g., 'connect://localhost:12345'.</para>
        /// </param>
        /// <param name="plugin_name">
        /// <para>The plugin name to be used; can be nullptr.</para>
        /// </param>
        /// <param name="error">
        /// <para>An error explaining what went wrong if the connect fails.</para>
        /// </param>
        /// <returns>
        /// <para>A process object for the connected process.</para>
        /// </returns>
        public LLDB.Process ConnectRemote(LLDB.Listener listener, string url, string plugin_name, LLDB.Error error)
        {
            if (ReferenceEquals(listener, null))
                throw new global::System.ArgumentNullException("listener", "Cannot be null because it is a C++ reference (&).");
            var arg0 = listener.__Instance;
            var arg1 = Marshal.StringToHGlobalAnsi(url);
            var arg2 = Marshal.StringToHGlobalAnsi(plugin_name);
            if (ReferenceEquals(error, null))
                throw new global::System.ArgumentNullException("error", "Cannot be null because it is a C++ reference (&).");
            var arg3 = error.__Instance;
            var __ret = new LLDB.Process.Internal();
            Internal.ConnectRemote_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment), arg0, arg1, arg2, arg3);
            Marshal.FreeHGlobal(arg1);
            Marshal.FreeHGlobal(arg2);
            return LLDB.Process.__CreateInstance(__ret);
        }

        public LLDB.FileSpec GetExecutable()
        {
            var __ret = new LLDB.FileSpec.Internal();
            Internal.GetExecutable_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment));
            return LLDB.FileSpec.__CreateInstance(__ret);
        }

        public bool AddModule(LLDB.Module module)
        {
            if (ReferenceEquals(module, null))
                throw new global::System.ArgumentNullException("module", "Cannot be null because it is a C++ reference (&).");
            var arg0 = module.__Instance;
            var __ret = Internal.AddModule_0((__Instance + __PointerAdjustment), arg0);
            return __ret;
        }

        public LLDB.Module AddModule(string path, string triple, string uuid)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(path);
            var arg1 = Marshal.StringToHGlobalAnsi(triple);
            var arg2 = Marshal.StringToHGlobalAnsi(uuid);
            var __ret = new LLDB.Module.Internal();
            Internal.AddModule_1(new IntPtr(&__ret), (__Instance + __PointerAdjustment), arg0, arg1, arg2);
            Marshal.FreeHGlobal(arg0);
            Marshal.FreeHGlobal(arg1);
            Marshal.FreeHGlobal(arg2);
            return LLDB.Module.__CreateInstance(__ret);
        }

        public LLDB.Module AddModule(string path, string triple, string uuid_cstr, string symfile)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(path);
            var arg1 = Marshal.StringToHGlobalAnsi(triple);
            var arg2 = Marshal.StringToHGlobalAnsi(uuid_cstr);
            var arg3 = Marshal.StringToHGlobalAnsi(symfile);
            var __ret = new LLDB.Module.Internal();
            Internal.AddModule_2(new IntPtr(&__ret), (__Instance + __PointerAdjustment), arg0, arg1, arg2, arg3);
            Marshal.FreeHGlobal(arg0);
            Marshal.FreeHGlobal(arg1);
            Marshal.FreeHGlobal(arg2);
            Marshal.FreeHGlobal(arg3);
            return LLDB.Module.__CreateInstance(__ret);
        }

        public LLDB.Module AddModule(LLDB.ModuleSpec module_spec)
        {
            if (ReferenceEquals(module_spec, null))
                throw new global::System.ArgumentNullException("module_spec", "Cannot be null because it is a C++ reference (&).");
            var arg0 = module_spec.__Instance;
            var __ret = new LLDB.Module.Internal();
            Internal.AddModule_3(new IntPtr(&__ret), (__Instance + __PointerAdjustment), arg0);
            return LLDB.Module.__CreateInstance(__ret);
        }

        public LLDB.Module GetModuleAtIndex(uint idx)
        {
            var __ret = new LLDB.Module.Internal();
            Internal.GetModuleAtIndex_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment), idx);
            return LLDB.Module.__CreateInstance(__ret);
        }

        public bool RemoveModule(LLDB.Module module)
        {
            var arg0 = ReferenceEquals(module, null) ? new LLDB.Module.Internal() : *(LLDB.Module.Internal*) (module.__Instance);
            var __ret = Internal.RemoveModule_0((__Instance + __PointerAdjustment), arg0);
            return __ret;
        }

        public LLDB.Debugger GetDebugger()
        {
            var __ret = new LLDB.Debugger.Internal();
            Internal.GetDebugger_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment));
            return LLDB.Debugger.__CreateInstance(__ret);
        }

        public LLDB.Module FindModule(LLDB.FileSpec file_spec)
        {
            if (ReferenceEquals(file_spec, null))
                throw new global::System.ArgumentNullException("file_spec", "Cannot be null because it is a C++ reference (&).");
            var arg0 = file_spec.__Instance;
            var __ret = new LLDB.Module.Internal();
            Internal.FindModule_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment), arg0);
            return LLDB.Module.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Set the base load address for a module section.</para>
        /// </summary>
        /// <param name="section">
        /// <para>The section whose base load address will be set within this</para>
        /// <para>target.</para>
        /// </param>
        /// <param name="section_base_addr">
        /// <para>The base address for the section.</para>
        /// </param>
        /// <returns>
        /// <para>An error to indicate success, fail, and any reason for</para>
        /// <para>failure.</para>
        /// </returns>
        public LLDB.Error SetSectionLoadAddress(LLDB.Section section, ulong section_base_addr)
        {
            var arg0 = ReferenceEquals(section, null) ? new LLDB.Section.Internal() : *(LLDB.Section.Internal*) (section.__Instance);
            var __ret = new LLDB.Error.Internal();
            Internal.SetSectionLoadAddress_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment), arg0, section_base_addr);
            return LLDB.Error.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Clear the base load address for a module section.</para>
        /// </summary>
        /// <param name="section">
        /// <para>The section whose base load address will be cleared within</para>
        /// <para>this target.</para>
        /// </param>
        /// <returns>
        /// <para>An error to indicate success, fail, and any reason for</para>
        /// <para>failure.</para>
        /// </returns>
        public LLDB.Error ClearSectionLoadAddress(LLDB.Section section)
        {
            var arg0 = ReferenceEquals(section, null) ? new LLDB.Section.Internal() : *(LLDB.Section.Internal*) (section.__Instance);
            var __ret = new LLDB.Error.Internal();
            Internal.ClearSectionLoadAddress_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment), arg0);
            return LLDB.Error.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Slide all file addresses for all module sections so that </para>
        /// <para>appears to loaded at these slide addresses.</para>
        /// </summary>
        /// <remarks>
        /// <para>When you need all sections within a module to be loaded at a </para>
        /// <para>rigid slide from the addresses found in the module object file,</para>
        /// <para>this function will allow you to easily and quickly slide all</para>
        /// <para>module sections.</para>
        /// </remarks>
        /// <param name="module">
        /// <para>The module to load.</para>
        /// </param>
        /// <param name="sections_offset">
        /// <para>An offset that will be applied to all section file addresses</para>
        /// <para>(the virtual addresses found in the object file itself).</para>
        /// </param>
        /// <returns>
        /// <para>An error to indicate success, fail, and any reason for</para>
        /// <para>failure.</para>
        /// </returns>
        public LLDB.Error SetModuleLoadAddress(LLDB.Module module, long sections_offset)
        {
            var arg0 = ReferenceEquals(module, null) ? new LLDB.Module.Internal() : *(LLDB.Module.Internal*) (module.__Instance);
            var __ret = new LLDB.Error.Internal();
            Internal.SetModuleLoadAddress_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment), arg0, sections_offset);
            return LLDB.Error.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Clear the section base load addresses for all sections in a module.</para>
        /// </summary>
        /// <param name="module">
        /// <para>The module to unload.</para>
        /// </param>
        /// <returns>
        /// <para>An error to indicate success, fail, and any reason for</para>
        /// <para>failure.</para>
        /// </returns>
        public LLDB.Error ClearModuleLoadAddress(LLDB.Module module)
        {
            var arg0 = ReferenceEquals(module, null) ? new LLDB.Module.Internal() : *(LLDB.Module.Internal*) (module.__Instance);
            var __ret = new LLDB.Error.Internal();
            Internal.ClearModuleLoadAddress_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment), arg0);
            return LLDB.Error.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Find functions by name.</para>
        /// </summary>
        /// <param name="name">
        /// <para>The name of the function we are looking for.</para>
        /// </param>
        /// <param name="name_type_mask">
        /// <para>A logical OR of one or more FunctionNameType enum bits that</para>
        /// <para>indicate what kind of names should be used when doing the</para>
        /// <para>lookup. Bits include fully qualified names, base names,</para>
        /// <para>C++ methods, or ObjC selectors.</para>
        /// <para>See FunctionNameType for more details.</para>
        /// </param>
        /// <returns>
        /// <para>A lldb::SBSymbolContextList that gets filled in with all of</para>
        /// <para>the symbol contexts for all the matches.</para>
        /// </returns>
        public LLDB.SymbolContextList FindFunctions(string name, uint name_type_mask)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var __ret = new LLDB.SymbolContextList.Internal();
            Internal.FindFunctions_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment), arg0, name_type_mask);
            Marshal.FreeHGlobal(arg0);
            return LLDB.SymbolContextList.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Find global and static variables by name.</para>
        /// </summary>
        /// <param name="name">
        /// <para>The name of the global or static variable we are looking</para>
        /// <para>for.</para>
        /// </param>
        /// <param name="max_matches">
        /// <para>Allow the number of matches to be limited to</para>
        /// </param>
        /// <returns>
        /// <para>A list of matched variables in an SBValueList.</para>
        /// </returns>
        public LLDB.ValueList FindGlobalVariables(string name, uint max_matches)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var __ret = new LLDB.ValueList.Internal();
            Internal.FindGlobalVariables_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment), arg0, max_matches);
            Marshal.FreeHGlobal(arg0);
            return LLDB.ValueList.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Find the first global (or static) variable by name.</para>
        /// </summary>
        /// <param name="name">
        /// <para>The name of the global or static variable we are looking</para>
        /// <para>for.</para>
        /// </param>
        /// <returns>
        /// <para>An SBValue that gets filled in with the found variable (if any).</para>
        /// </returns>
        public LLDB.Value FindFirstGlobalVariable(string name)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var __ret = new LLDB.Value.Internal();
            Internal.FindFirstGlobalVariable_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment), arg0);
            Marshal.FreeHGlobal(arg0);
            return LLDB.Value.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Find global and static variables by pattern.</para>
        /// </summary>
        /// <param name="name">
        /// <para>The pattern to search for global or static variables</para>
        /// </param>
        /// <param name="max_matches">
        /// <para>Allow the number of matches to be limited to</para>
        /// </param>
        /// <param name="matchtype">
        /// <para>The match type to use.</para>
        /// </param>
        /// <returns>
        /// <para>A list of matched variables in an SBValueList.</para>
        /// </returns>
        public LLDB.ValueList FindGlobalVariables(string name, uint max_matches, LLDB.MatchType matchtype)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var arg2 = matchtype;
            var __ret = new LLDB.ValueList.Internal();
            Internal.FindGlobalVariables_1(new IntPtr(&__ret), (__Instance + __PointerAdjustment), arg0, max_matches, arg2);
            Marshal.FreeHGlobal(arg0);
            return LLDB.ValueList.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Find global functions by their name with pattern matching.</para>
        /// </summary>
        /// <param name="name">
        /// <para>The pattern to search for global or static variables</para>
        /// </param>
        /// <param name="max_matches">
        /// <para>Allow the number of matches to be limited to</para>
        /// </param>
        /// <param name="matchtype">
        /// <para>The match type to use.</para>
        /// </param>
        /// <returns>
        /// <para>A list of matched variables in an SBValueList.</para>
        /// </returns>
        public LLDB.SymbolContextList FindGlobalFunctions(string name, uint max_matches, LLDB.MatchType matchtype)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var arg2 = matchtype;
            var __ret = new LLDB.SymbolContextList.Internal();
            Internal.FindGlobalFunctions_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment), arg0, max_matches, arg2);
            Marshal.FreeHGlobal(arg0);
            return LLDB.SymbolContextList.__CreateInstance(__ret);
        }

        public void Clear()
        {
            Internal.Clear_0((__Instance + __PointerAdjustment));
        }

        /// <summary>
        /// <para>Resolve a current file address into a section offset address.</para>
        /// </summary>
        /// <returns>
        /// <para>An SBAddress which will be valid if...</para>
        /// </returns>
        public LLDB.Address ResolveFileAddress(ulong file_addr)
        {
            var __ret = new LLDB.Address.Internal();
            Internal.ResolveFileAddress_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment), file_addr);
            return LLDB.Address.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Resolve a current load address into a section offset address.</para>
        /// </summary>
        /// <param name="vm_addr">
        /// <para>A virtual address from the current process state that is to</para>
        /// <para>be translated into a section offset address.</para>
        /// </param>
        /// <returns>
        /// <para>An SBAddress which will be valid if</para>
        /// <para>was</para>
        /// <para>successfully resolved into a section offset address, or an</para>
        /// <para>invalid SBAddress if</para>
        /// <para>doesn't resolve to a section</para>
        /// <para>in a module.</para>
        /// </returns>
        public LLDB.Address ResolveLoadAddress(ulong vm_addr)
        {
            var __ret = new LLDB.Address.Internal();
            Internal.ResolveLoadAddress_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment), vm_addr);
            return LLDB.Address.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Resolve a current load address into a section offset address</para>
        /// <para>using the process stop ID to identify a time in the past.</para>
        /// </summary>
        /// <param name="stop_id">
        /// <para>Each time a process stops, the process stop ID integer gets</para>
        /// <para>incremented. These stop IDs are used to identify past times</para>
        /// <para>and can be used in history objects as a cheap way to store</para>
        /// <para>the time at which the sample was taken. Specifying</para>
        /// <para>UINT32_MAX will always resolve the address using the</para>
        /// <para>currently loaded sections.</para>
        /// </param>
        /// <param name="vm_addr">
        /// <para>A virtual address from the current process state that is to</para>
        /// <para>be translated into a section offset address.</para>
        /// </param>
        /// <returns>
        /// <para>An SBAddress which will be valid if</para>
        /// <para>was</para>
        /// <para>successfully resolved into a section offset address, or an</para>
        /// <para>invalid SBAddress if</para>
        /// <para>doesn't resolve to a section</para>
        /// <para>in a module.</para>
        /// </returns>
        public LLDB.Address ResolvePastLoadAddress(uint stop_id, ulong vm_addr)
        {
            var __ret = new LLDB.Address.Internal();
            Internal.ResolvePastLoadAddress_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment), stop_id, vm_addr);
            return LLDB.Address.__CreateInstance(__ret);
        }

        public LLDB.SymbolContext ResolveSymbolContextForAddress(LLDB.Address addr, uint resolve_scope)
        {
            if (ReferenceEquals(addr, null))
                throw new global::System.ArgumentNullException("addr", "Cannot be null because it is a C++ reference (&).");
            var arg0 = addr.__Instance;
            var __ret = new LLDB.SymbolContext.Internal();
            Internal.ResolveSymbolContextForAddress_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment), arg0, resolve_scope);
            return LLDB.SymbolContext.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Read target memory. If a target process is running then memory  </para>
        /// <para>is read from here. Otherwise the memory is read from the object</para>
        /// <para>files. For a target whose bytes are sized as a multiple of host</para>
        /// <para>bytes, the data read back will preserve the target's byte order.</para>
        /// </summary>
        /// <param name="addr">
        /// <para>A target address to read from.</para>
        /// </param>
        /// <param name="buf">
        /// <para>The buffer to read memory into.</para>
        /// </param>
        /// <param name="size">
        /// <para>The maximum number of host bytes to read in the buffer passed</para>
        /// <para>into this call</para>
        /// </param>
        /// <param name="error">
        /// <para>Error information is written here if the memory read fails.</para>
        /// </param>
        /// <returns>
        /// <para>The amount of data read in host bytes.</para>
        /// </returns>
        public uint ReadMemory(LLDB.Address addr, global::System.IntPtr buf, uint size, LLDB.Error error)
        {
            var arg0 = ReferenceEquals(addr, null) ? new LLDB.Address.Internal() : *(LLDB.Address.Internal*) (addr.__Instance);
            var arg1 = buf;
            if (ReferenceEquals(error, null))
                throw new global::System.ArgumentNullException("error", "Cannot be null because it is a C++ reference (&).");
            var arg3 = error.__Instance;
            var __ret = Internal.ReadMemory_0((__Instance + __PointerAdjustment), arg0, arg1, size, arg3);
            return __ret;
        }

        public LLDB.Breakpoint BreakpointCreateByLocation(string file, uint line)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(file);
            var __ret = new LLDB.Breakpoint.Internal();
            Internal.BreakpointCreateByLocation_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment), arg0, line);
            Marshal.FreeHGlobal(arg0);
            return LLDB.Breakpoint.__CreateInstance(__ret);
        }

        public LLDB.Breakpoint BreakpointCreateByLocation(LLDB.FileSpec file_spec, uint line)
        {
            if (ReferenceEquals(file_spec, null))
                throw new global::System.ArgumentNullException("file_spec", "Cannot be null because it is a C++ reference (&).");
            var arg0 = file_spec.__Instance;
            var __ret = new LLDB.Breakpoint.Internal();
            Internal.BreakpointCreateByLocation_1(new IntPtr(&__ret), (__Instance + __PointerAdjustment), arg0, line);
            return LLDB.Breakpoint.__CreateInstance(__ret);
        }

        public LLDB.Breakpoint BreakpointCreateByLocation(LLDB.FileSpec file_spec, uint line, ulong offset)
        {
            if (ReferenceEquals(file_spec, null))
                throw new global::System.ArgumentNullException("file_spec", "Cannot be null because it is a C++ reference (&).");
            var arg0 = file_spec.__Instance;
            var __ret = new LLDB.Breakpoint.Internal();
            Internal.BreakpointCreateByLocation_2(new IntPtr(&__ret), (__Instance + __PointerAdjustment), arg0, line, offset);
            return LLDB.Breakpoint.__CreateInstance(__ret);
        }

        public LLDB.Breakpoint BreakpointCreateByName(string symbol_name, string module_name)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(symbol_name);
            var arg1 = Marshal.StringToHGlobalAnsi(module_name);
            var __ret = new LLDB.Breakpoint.Internal();
            Internal.BreakpointCreateByName_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment), arg0, arg1);
            Marshal.FreeHGlobal(arg0);
            Marshal.FreeHGlobal(arg1);
            return LLDB.Breakpoint.__CreateInstance(__ret);
        }

        public LLDB.Breakpoint BreakpointCreateByName(string symbol_name, LLDB.FileSpecList module_list, LLDB.FileSpecList comp_unit_list)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(symbol_name);
            if (ReferenceEquals(module_list, null))
                throw new global::System.ArgumentNullException("module_list", "Cannot be null because it is a C++ reference (&).");
            var arg1 = module_list.__Instance;
            if (ReferenceEquals(comp_unit_list, null))
                throw new global::System.ArgumentNullException("comp_unit_list", "Cannot be null because it is a C++ reference (&).");
            var arg2 = comp_unit_list.__Instance;
            var __ret = new LLDB.Breakpoint.Internal();
            Internal.BreakpointCreateByName_1(new IntPtr(&__ret), (__Instance + __PointerAdjustment), arg0, arg1, arg2);
            Marshal.FreeHGlobal(arg0);
            return LLDB.Breakpoint.__CreateInstance(__ret);
        }

        public LLDB.Breakpoint BreakpointCreateByName(string symbol_name, uint name_type_mask, LLDB.FileSpecList module_list, LLDB.FileSpecList comp_unit_list)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(symbol_name);
            if (ReferenceEquals(module_list, null))
                throw new global::System.ArgumentNullException("module_list", "Cannot be null because it is a C++ reference (&).");
            var arg2 = module_list.__Instance;
            if (ReferenceEquals(comp_unit_list, null))
                throw new global::System.ArgumentNullException("comp_unit_list", "Cannot be null because it is a C++ reference (&).");
            var arg3 = comp_unit_list.__Instance;
            var __ret = new LLDB.Breakpoint.Internal();
            Internal.BreakpointCreateByName_2(new IntPtr(&__ret), (__Instance + __PointerAdjustment), arg0, name_type_mask, arg2, arg3);
            Marshal.FreeHGlobal(arg0);
            return LLDB.Breakpoint.__CreateInstance(__ret);
        }

        public LLDB.Breakpoint BreakpointCreateByName(string symbol_name, uint name_type_mask, LLDB.LanguageType symbol_language, LLDB.FileSpecList module_list, LLDB.FileSpecList comp_unit_list)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(symbol_name);
            var arg2 = symbol_language;
            if (ReferenceEquals(module_list, null))
                throw new global::System.ArgumentNullException("module_list", "Cannot be null because it is a C++ reference (&).");
            var arg3 = module_list.__Instance;
            if (ReferenceEquals(comp_unit_list, null))
                throw new global::System.ArgumentNullException("comp_unit_list", "Cannot be null because it is a C++ reference (&).");
            var arg4 = comp_unit_list.__Instance;
            var __ret = new LLDB.Breakpoint.Internal();
            Internal.BreakpointCreateByName_3(new IntPtr(&__ret), (__Instance + __PointerAdjustment), arg0, name_type_mask, arg2, arg3, arg4);
            Marshal.FreeHGlobal(arg0);
            return LLDB.Breakpoint.__CreateInstance(__ret);
        }

        public LLDB.Breakpoint BreakpointCreateByRegex(string symbol_name_regex, string module_name)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(symbol_name_regex);
            var arg1 = Marshal.StringToHGlobalAnsi(module_name);
            var __ret = new LLDB.Breakpoint.Internal();
            Internal.BreakpointCreateByRegex_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment), arg0, arg1);
            Marshal.FreeHGlobal(arg0);
            Marshal.FreeHGlobal(arg1);
            return LLDB.Breakpoint.__CreateInstance(__ret);
        }

        public LLDB.Breakpoint BreakpointCreateByRegex(string symbol_name_regex, LLDB.FileSpecList module_list, LLDB.FileSpecList comp_unit_list)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(symbol_name_regex);
            if (ReferenceEquals(module_list, null))
                throw new global::System.ArgumentNullException("module_list", "Cannot be null because it is a C++ reference (&).");
            var arg1 = module_list.__Instance;
            if (ReferenceEquals(comp_unit_list, null))
                throw new global::System.ArgumentNullException("comp_unit_list", "Cannot be null because it is a C++ reference (&).");
            var arg2 = comp_unit_list.__Instance;
            var __ret = new LLDB.Breakpoint.Internal();
            Internal.BreakpointCreateByRegex_1(new IntPtr(&__ret), (__Instance + __PointerAdjustment), arg0, arg1, arg2);
            Marshal.FreeHGlobal(arg0);
            return LLDB.Breakpoint.__CreateInstance(__ret);
        }

        public LLDB.Breakpoint BreakpointCreateByRegex(string symbol_name_regex, LLDB.LanguageType symbol_language, LLDB.FileSpecList module_list, LLDB.FileSpecList comp_unit_list)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(symbol_name_regex);
            var arg1 = symbol_language;
            if (ReferenceEquals(module_list, null))
                throw new global::System.ArgumentNullException("module_list", "Cannot be null because it is a C++ reference (&).");
            var arg2 = module_list.__Instance;
            if (ReferenceEquals(comp_unit_list, null))
                throw new global::System.ArgumentNullException("comp_unit_list", "Cannot be null because it is a C++ reference (&).");
            var arg3 = comp_unit_list.__Instance;
            var __ret = new LLDB.Breakpoint.Internal();
            Internal.BreakpointCreateByRegex_2(new IntPtr(&__ret), (__Instance + __PointerAdjustment), arg0, arg1, arg2, arg3);
            Marshal.FreeHGlobal(arg0);
            return LLDB.Breakpoint.__CreateInstance(__ret);
        }

        public LLDB.Breakpoint BreakpointCreateBySourceRegex(string source_regex, LLDB.FileSpec source_file, string module_name)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(source_regex);
            if (ReferenceEquals(source_file, null))
                throw new global::System.ArgumentNullException("source_file", "Cannot be null because it is a C++ reference (&).");
            var arg1 = source_file.__Instance;
            var arg2 = Marshal.StringToHGlobalAnsi(module_name);
            var __ret = new LLDB.Breakpoint.Internal();
            Internal.BreakpointCreateBySourceRegex_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment), arg0, arg1, arg2);
            Marshal.FreeHGlobal(arg0);
            Marshal.FreeHGlobal(arg2);
            return LLDB.Breakpoint.__CreateInstance(__ret);
        }

        public LLDB.Breakpoint BreakpointCreateBySourceRegex(string source_regex, LLDB.FileSpecList module_list, LLDB.FileSpecList source_file)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(source_regex);
            if (ReferenceEquals(module_list, null))
                throw new global::System.ArgumentNullException("module_list", "Cannot be null because it is a C++ reference (&).");
            var arg1 = module_list.__Instance;
            if (ReferenceEquals(source_file, null))
                throw new global::System.ArgumentNullException("source_file", "Cannot be null because it is a C++ reference (&).");
            var arg2 = source_file.__Instance;
            var __ret = new LLDB.Breakpoint.Internal();
            Internal.BreakpointCreateBySourceRegex_1(new IntPtr(&__ret), (__Instance + __PointerAdjustment), arg0, arg1, arg2);
            Marshal.FreeHGlobal(arg0);
            return LLDB.Breakpoint.__CreateInstance(__ret);
        }

        public LLDB.Breakpoint BreakpointCreateForException(LLDB.LanguageType language, bool catch_bp, bool throw_bp)
        {
            var arg0 = language;
            var __ret = new LLDB.Breakpoint.Internal();
            Internal.BreakpointCreateForException_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment), arg0, catch_bp, throw_bp);
            return LLDB.Breakpoint.__CreateInstance(__ret);
        }

        public LLDB.Breakpoint BreakpointCreateByAddress(ulong address)
        {
            var __ret = new LLDB.Breakpoint.Internal();
            Internal.BreakpointCreateByAddress_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment), address);
            return LLDB.Breakpoint.__CreateInstance(__ret);
        }

        public LLDB.Breakpoint BreakpointCreateBySBAddress(LLDB.Address address)
        {
            if (ReferenceEquals(address, null))
                throw new global::System.ArgumentNullException("address", "Cannot be null because it is a C++ reference (&).");
            var arg0 = address.__Instance;
            var __ret = new LLDB.Breakpoint.Internal();
            Internal.BreakpointCreateBySBAddress_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment), arg0);
            return LLDB.Breakpoint.__CreateInstance(__ret);
        }

        public LLDB.Breakpoint GetBreakpointAtIndex(uint idx)
        {
            var __ret = new LLDB.Breakpoint.Internal();
            Internal.GetBreakpointAtIndex_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment), idx);
            return LLDB.Breakpoint.__CreateInstance(__ret);
        }

        public bool BreakpointDelete(int break_id)
        {
            var __ret = Internal.BreakpointDelete_0((__Instance + __PointerAdjustment), break_id);
            return __ret;
        }

        public LLDB.Breakpoint FindBreakpointByID(int break_id)
        {
            var __ret = new LLDB.Breakpoint.Internal();
            Internal.FindBreakpointByID_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment), break_id);
            return LLDB.Breakpoint.__CreateInstance(__ret);
        }

        public bool EnableAllBreakpoints()
        {
            var __ret = Internal.EnableAllBreakpoints_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public bool DisableAllBreakpoints()
        {
            var __ret = Internal.DisableAllBreakpoints_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public bool DeleteAllBreakpoints()
        {
            var __ret = Internal.DeleteAllBreakpoints_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public LLDB.Watchpoint GetWatchpointAtIndex(uint idx)
        {
            var __ret = new LLDB.Watchpoint.Internal();
            Internal.GetWatchpointAtIndex_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment), idx);
            return LLDB.Watchpoint.__CreateInstance(__ret);
        }

        public bool DeleteWatchpoint(int watch_id)
        {
            var __ret = Internal.DeleteWatchpoint_0((__Instance + __PointerAdjustment), watch_id);
            return __ret;
        }

        public LLDB.Watchpoint FindWatchpointByID(int watch_id)
        {
            var __ret = new LLDB.Watchpoint.Internal();
            Internal.FindWatchpointByID_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment), watch_id);
            return LLDB.Watchpoint.__CreateInstance(__ret);
        }

        public LLDB.Watchpoint WatchAddress(ulong addr, uint size, bool read, bool write, LLDB.Error error)
        {
            if (ReferenceEquals(error, null))
                throw new global::System.ArgumentNullException("error", "Cannot be null because it is a C++ reference (&).");
            var arg4 = error.__Instance;
            var __ret = new LLDB.Watchpoint.Internal();
            Internal.WatchAddress_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment), addr, size, read, write, arg4);
            return LLDB.Watchpoint.__CreateInstance(__ret);
        }

        public bool EnableAllWatchpoints()
        {
            var __ret = Internal.EnableAllWatchpoints_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public bool DisableAllWatchpoints()
        {
            var __ret = Internal.DisableAllWatchpoints_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public bool DeleteAllWatchpoints()
        {
            var __ret = Internal.DeleteAllWatchpoints_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public LLDB.Broadcaster GetBroadcaster()
        {
            var __ret = new LLDB.Broadcaster.Internal();
            Internal.GetBroadcaster_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment));
            return LLDB.Broadcaster.__CreateInstance(__ret);
        }

        public LLDB.Type FindFirstType(string type)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(type);
            var __ret = new LLDB.Type.Internal();
            Internal.FindFirstType_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment), arg0);
            Marshal.FreeHGlobal(arg0);
            return LLDB.Type.__CreateInstance(__ret);
        }

        public LLDB.TypeList FindTypes(string type)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(type);
            var __ret = new LLDB.TypeList.Internal();
            Internal.FindTypes_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment), arg0);
            Marshal.FreeHGlobal(arg0);
            return LLDB.TypeList.__CreateInstance(__ret);
        }

        public LLDB.Type GetBasicType(LLDB.BasicType type)
        {
            var arg0 = type;
            var __ret = new LLDB.Type.Internal();
            Internal.GetBasicType_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment), arg0);
            return LLDB.Type.__CreateInstance(__ret);
        }

        public LLDB.Value CreateValueFromAddress(string name, LLDB.Address addr, LLDB.Type type)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var arg1 = ReferenceEquals(addr, null) ? new LLDB.Address.Internal() : *(LLDB.Address.Internal*) (addr.__Instance);
            var arg2 = ReferenceEquals(type, null) ? new LLDB.Type.Internal() : *(LLDB.Type.Internal*) (type.__Instance);
            var __ret = new LLDB.Value.Internal();
            Internal.CreateValueFromAddress_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment), arg0, arg1, arg2);
            Marshal.FreeHGlobal(arg0);
            return LLDB.Value.__CreateInstance(__ret);
        }

        public LLDB.Value CreateValueFromData(string name, LLDB.Data data, LLDB.Type type)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var arg1 = ReferenceEquals(data, null) ? new LLDB.Data.Internal() : *(LLDB.Data.Internal*) (data.__Instance);
            var arg2 = ReferenceEquals(type, null) ? new LLDB.Type.Internal() : *(LLDB.Type.Internal*) (type.__Instance);
            var __ret = new LLDB.Value.Internal();
            Internal.CreateValueFromData_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment), arg0, arg1, arg2);
            Marshal.FreeHGlobal(arg0);
            return LLDB.Value.__CreateInstance(__ret);
        }

        public LLDB.Value CreateValueFromExpression(string name, string expr)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var arg1 = Marshal.StringToHGlobalAnsi(expr);
            var __ret = new LLDB.Value.Internal();
            Internal.CreateValueFromExpression_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment), arg0, arg1);
            Marshal.FreeHGlobal(arg0);
            Marshal.FreeHGlobal(arg1);
            return LLDB.Value.__CreateInstance(__ret);
        }

        public LLDB.SourceManager GetSourceManager()
        {
            var __ret = new LLDB.SourceManager.Internal();
            Internal.GetSourceManager_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment));
            return LLDB.SourceManager.__CreateInstance(__ret);
        }

        public LLDB.InstructionList ReadInstructions(LLDB.Address base_addr, uint count)
        {
            var arg0 = ReferenceEquals(base_addr, null) ? new LLDB.Address.Internal() : *(LLDB.Address.Internal*) (base_addr.__Instance);
            var __ret = new LLDB.InstructionList.Internal();
            Internal.ReadInstructions_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment), arg0, count);
            return LLDB.InstructionList.__CreateInstance(__ret);
        }

        public LLDB.InstructionList ReadInstructions(LLDB.Address base_addr, uint count, string flavor_string)
        {
            var arg0 = ReferenceEquals(base_addr, null) ? new LLDB.Address.Internal() : *(LLDB.Address.Internal*) (base_addr.__Instance);
            var arg2 = Marshal.StringToHGlobalAnsi(flavor_string);
            var __ret = new LLDB.InstructionList.Internal();
            Internal.ReadInstructions_1(new IntPtr(&__ret), (__Instance + __PointerAdjustment), arg0, count, arg2);
            Marshal.FreeHGlobal(arg2);
            return LLDB.InstructionList.__CreateInstance(__ret);
        }

        public LLDB.InstructionList GetInstructions(LLDB.Address base_addr, global::System.IntPtr buf, uint size)
        {
            var arg0 = ReferenceEquals(base_addr, null) ? new LLDB.Address.Internal() : *(LLDB.Address.Internal*) (base_addr.__Instance);
            var arg1 = buf;
            var __ret = new LLDB.InstructionList.Internal();
            Internal.GetInstructions_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment), arg0, arg1, size);
            return LLDB.InstructionList.__CreateInstance(__ret);
        }

        public LLDB.InstructionList GetInstructionsWithFlavor(LLDB.Address base_addr, string flavor_string, global::System.IntPtr buf, uint size)
        {
            var arg0 = ReferenceEquals(base_addr, null) ? new LLDB.Address.Internal() : *(LLDB.Address.Internal*) (base_addr.__Instance);
            var arg1 = Marshal.StringToHGlobalAnsi(flavor_string);
            var arg2 = buf;
            var __ret = new LLDB.InstructionList.Internal();
            Internal.GetInstructionsWithFlavor_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment), arg0, arg1, arg2, size);
            Marshal.FreeHGlobal(arg1);
            return LLDB.InstructionList.__CreateInstance(__ret);
        }

        public LLDB.InstructionList GetInstructions(ulong base_addr, global::System.IntPtr buf, uint size)
        {
            var arg1 = buf;
            var __ret = new LLDB.InstructionList.Internal();
            Internal.GetInstructions_1(new IntPtr(&__ret), (__Instance + __PointerAdjustment), base_addr, arg1, size);
            return LLDB.InstructionList.__CreateInstance(__ret);
        }

        public LLDB.InstructionList GetInstructionsWithFlavor(ulong base_addr, string flavor_string, global::System.IntPtr buf, uint size)
        {
            var arg1 = Marshal.StringToHGlobalAnsi(flavor_string);
            var arg2 = buf;
            var __ret = new LLDB.InstructionList.Internal();
            Internal.GetInstructionsWithFlavor_1(new IntPtr(&__ret), (__Instance + __PointerAdjustment), base_addr, arg1, arg2, size);
            Marshal.FreeHGlobal(arg1);
            return LLDB.InstructionList.__CreateInstance(__ret);
        }

        public LLDB.SymbolContextList FindSymbols(string name, LLDB.SymbolType type)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var arg1 = type;
            var __ret = new LLDB.SymbolContextList.Internal();
            Internal.FindSymbols_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment), arg0, arg1);
            Marshal.FreeHGlobal(arg0);
            return LLDB.SymbolContextList.__CreateInstance(__ret);
        }

        public static bool operator ==(LLDB.Target __op, LLDB.Target rhs)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool rhsNull = ReferenceEquals(rhs, null);
            if (__opNull || rhsNull)
                return __opNull && rhsNull;
            var arg0 = __op.__Instance;
            var arg1 = rhs.__Instance;
            var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as Target;
        }

        public override int GetHashCode()
        {
            if (__Instance == global::System.IntPtr.Zero)
                return global::System.IntPtr.Zero.GetHashCode();
            return (*(Internal*) __Instance).GetHashCode();
        }

        public static bool operator !=(LLDB.Target __op, LLDB.Target rhs)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool rhsNull = ReferenceEquals(rhs, null);
            if (__opNull || rhsNull)
                return !(__opNull && rhsNull);
            var arg0 = __op.__Instance;
            var arg1 = rhs.__Instance;
            var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
            return __ret;
        }

        public bool GetDescription(LLDB.Stream description, LLDB.DescriptionLevel description_level)
        {
            if (ReferenceEquals(description, null))
                throw new global::System.ArgumentNullException("description", "Cannot be null because it is a C++ reference (&).");
            var arg0 = description.__Instance;
            var arg1 = description_level;
            var __ret = Internal.GetDescription_0((__Instance + __PointerAdjustment), arg0, arg1);
            return __ret;
        }

        public LLDB.Value EvaluateExpression(string expr)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(expr);
            var __ret = new LLDB.Value.Internal();
            Internal.EvaluateExpression_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment), arg0);
            Marshal.FreeHGlobal(arg0);
            return LLDB.Value.__CreateInstance(__ret);
        }

        public LLDB.Value EvaluateExpression(string expr, LLDB.ExpressionOptions options)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(expr);
            if (ReferenceEquals(options, null))
                throw new global::System.ArgumentNullException("options", "Cannot be null because it is a C++ reference (&).");
            var arg1 = options.__Instance;
            var __ret = new LLDB.Value.Internal();
            Internal.EvaluateExpression_1(new IntPtr(&__ret), (__Instance + __PointerAdjustment), arg0, arg1);
            Marshal.FreeHGlobal(arg0);
            return LLDB.Value.__CreateInstance(__ret);
        }

        public LLDB.LaunchInfo GetLaunchInfo()
        {
            var __ret = new LLDB.LaunchInfo.Internal();
            Internal.GetLaunchInfo_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment));
            return LLDB.LaunchInfo.__CreateInstance(__ret);
        }

        public static bool EventIsTargetEvent(LLDB.Event @event)
        {
            if (ReferenceEquals(@event, null))
                throw new global::System.ArgumentNullException("@event", "Cannot be null because it is a C++ reference (&).");
            var arg0 = @event.__Instance;
            var __ret = Internal.EventIsTargetEvent_0(arg0);
            return __ret;
        }

        public static LLDB.Target GetTargetFromEvent(LLDB.Event @event)
        {
            if (ReferenceEquals(@event, null))
                throw new global::System.ArgumentNullException("@event", "Cannot be null because it is a C++ reference (&).");
            var arg0 = @event.__Instance;
            var __ret = new LLDB.Target.Internal();
            Internal.GetTargetFromEvent_0(new IntPtr(&__ret), arg0);
            return LLDB.Target.__CreateInstance(__ret);
        }

        public static uint GetNumModulesFromEvent(LLDB.Event @event)
        {
            if (ReferenceEquals(@event, null))
                throw new global::System.ArgumentNullException("@event", "Cannot be null because it is a C++ reference (&).");
            var arg0 = @event.__Instance;
            var __ret = Internal.GetNumModulesFromEvent_0(arg0);
            return __ret;
        }

        public static LLDB.Module GetModuleAtIndexFromEvent(uint idx, LLDB.Event @event)
        {
            if (ReferenceEquals(@event, null))
                throw new global::System.ArgumentNullException("@event", "Cannot be null because it is a C++ reference (&).");
            var arg1 = @event.__Instance;
            var __ret = new LLDB.Module.Internal();
            Internal.GetModuleAtIndexFromEvent_0(new IntPtr(&__ret), idx, arg1);
            return LLDB.Module.__CreateInstance(__ret);
        }

        public static string BroadcasterClassName
        {
            get
            {
                var __ret = Internal.GetBroadcasterClassName_0();
                return Marshal.PtrToStringAnsi(__ret);
            }
        }

        public uint NumModules
        {
            get
            {
                var __ret = Internal.GetNumModules_0((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public LLDB.ByteOrder ByteOrder
        {
            get
            {
                var __ret = Internal.GetByteOrder_0((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public uint AddressByteSize
        {
            get
            {
                var __ret = Internal.GetAddressByteSize_0((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public string Triple
        {
            get
            {
                var __ret = Internal.GetTriple_0((__Instance + __PointerAdjustment));
                return Marshal.PtrToStringAnsi(__ret);
            }
        }

        public uint DataByteSize
        {
            get
            {
                var __ret = Internal.GetDataByteSize_0((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public uint CodeByteSize
        {
            get
            {
                var __ret = Internal.GetCodeByteSize_0((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public uint NumBreakpoints
        {
            get
            {
                var __ret = Internal.GetNumBreakpoints_0((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public uint NumWatchpoints
        {
            get
            {
                var __ret = Internal.GetNumWatchpoints_0((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public ulong StackRedZoneSize
        {
            get
            {
                var __ret = Internal.GetStackRedZoneSize_0((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public LLDB.LaunchInfo LaunchInfo
        {
            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var arg0 = value.__Instance;
                Internal.SetLaunchInfo_0((__Instance + __PointerAdjustment), arg0);
            }
        }
    }
}
