//----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace LLDB
{
    public unsafe partial class CommandInterpreterRunOptions : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0SBCommandInterpreterRunOptions@lldb@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0SBCommandInterpreterRunOptions@lldb@@QAE@ABV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??1SBCommandInterpreterRunOptions@lldb@@QAE@XZ")]
            internal static extern void dtor_0(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetStopOnContinue@SBCommandInterpreterRunOptions@lldb@@QBE_NXZ")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool GetStopOnContinue_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?SetStopOnContinue@SBCommandInterpreterRunOptions@lldb@@QAEX_N@Z")]
            internal static extern void SetStopOnContinue_0(global::System.IntPtr instance, bool _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetStopOnError@SBCommandInterpreterRunOptions@lldb@@QBE_NXZ")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool GetStopOnError_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?SetStopOnError@SBCommandInterpreterRunOptions@lldb@@QAEX_N@Z")]
            internal static extern void SetStopOnError_0(global::System.IntPtr instance, bool _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetStopOnCrash@SBCommandInterpreterRunOptions@lldb@@QBE_NXZ")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool GetStopOnCrash_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?SetStopOnCrash@SBCommandInterpreterRunOptions@lldb@@QAEX_N@Z")]
            internal static extern void SetStopOnCrash_0(global::System.IntPtr instance, bool _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetEchoCommands@SBCommandInterpreterRunOptions@lldb@@QBE_NXZ")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool GetEchoCommands_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?SetEchoCommands@SBCommandInterpreterRunOptions@lldb@@QAEX_N@Z")]
            internal static extern void SetEchoCommands_0(global::System.IntPtr instance, bool _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetPrintResults@SBCommandInterpreterRunOptions@lldb@@QBE_NXZ")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool GetPrintResults_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?SetPrintResults@SBCommandInterpreterRunOptions@lldb@@QAEX_N@Z")]
            internal static extern void SetPrintResults_0(global::System.IntPtr instance, bool _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetAddToHistory@SBCommandInterpreterRunOptions@lldb@@QBE_NXZ")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool GetAddToHistory_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?SetAddToHistory@SBCommandInterpreterRunOptions@lldb@@QAEX_N@Z")]
            internal static extern void SetAddToHistory_0(global::System.IntPtr instance, bool _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, CommandInterpreterRunOptions> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, CommandInterpreterRunOptions>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        public static CommandInterpreterRunOptions __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new CommandInterpreterRunOptions(native.ToPointer(), skipVTables);
        }

        public static CommandInterpreterRunOptions __CreateInstance(CommandInterpreterRunOptions.Internal native, bool skipVTables = false)
        {
            return new CommandInterpreterRunOptions(native, skipVTables);
        }

        private static void* __CopyValue(CommandInterpreterRunOptions.Internal native)
        {
            var ret = Marshal.AllocHGlobal(4);
            *(CommandInterpreterRunOptions.Internal*) ret = native;
            return ret.ToPointer();
        }

        private CommandInterpreterRunOptions(CommandInterpreterRunOptions.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected CommandInterpreterRunOptions(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public CommandInterpreterRunOptions()
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            Internal.ctor_0((__Instance + __PointerAdjustment));
        }

        public CommandInterpreterRunOptions(LLDB.CommandInterpreterRunOptions _0)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((CommandInterpreterRunOptions.Internal*) __Instance) = *((CommandInterpreterRunOptions.Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        protected virtual void Dispose(bool disposing)
        {
            LLDB.CommandInterpreterRunOptions __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            Internal.dtor_0((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public bool StopOnContinue
        {
            get
            {
                var __ret = Internal.GetStopOnContinue_0((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                Internal.SetStopOnContinue_0((__Instance + __PointerAdjustment), value);
            }
        }

        public bool StopOnError
        {
            get
            {
                var __ret = Internal.GetStopOnError_0((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                Internal.SetStopOnError_0((__Instance + __PointerAdjustment), value);
            }
        }

        public bool StopOnCrash
        {
            get
            {
                var __ret = Internal.GetStopOnCrash_0((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                Internal.SetStopOnCrash_0((__Instance + __PointerAdjustment), value);
            }
        }

        public bool EchoCommands
        {
            get
            {
                var __ret = Internal.GetEchoCommands_0((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                Internal.SetEchoCommands_0((__Instance + __PointerAdjustment), value);
            }
        }

        public bool PrintResults
        {
            get
            {
                var __ret = Internal.GetPrintResults_0((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                Internal.SetPrintResults_0((__Instance + __PointerAdjustment), value);
            }
        }

        public bool AddToHistory
        {
            get
            {
                var __ret = Internal.GetAddToHistory_0((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                Internal.SetAddToHistory_0((__Instance + __PointerAdjustment), value);
            }
        }
    }

    public unsafe partial class CommandInterpreter : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr m_opaque_ptr;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0SBCommandInterpreter@lldb@@QAE@ABV01@@Z")]
            internal static extern global::System.IntPtr cctor_0(global::System.IntPtr instance, global::System.IntPtr rhs);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??1SBCommandInterpreter@lldb@@QAE@XZ")]
            internal static extern void dtor_0(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetArgumentTypeAsCString@SBCommandInterpreter@lldb@@SAPBDW4CommandArgumentType@2@@Z")]
            internal static extern global::System.IntPtr GetArgumentTypeAsCString_0(LLDB.CommandArgumentType arg_type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetArgumentDescriptionAsCString@SBCommandInterpreter@lldb@@SAPBDW4CommandArgumentType@2@@Z")]
            internal static extern global::System.IntPtr GetArgumentDescriptionAsCString_0(LLDB.CommandArgumentType arg_type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?EventIsCommandInterpreterEvent@SBCommandInterpreter@lldb@@SA_NABVSBEvent@2@@Z")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool EventIsCommandInterpreterEvent_0(global::System.IntPtr @event);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?IsValid@SBCommandInterpreter@lldb@@QBE_NXZ")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsValid_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?CommandExists@SBCommandInterpreter@lldb@@QAE_NPBD@Z")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool CommandExists_0(global::System.IntPtr instance, global::System.IntPtr cmd);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?AliasExists@SBCommandInterpreter@lldb@@QAE_NPBD@Z")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool AliasExists_0(global::System.IntPtr instance, global::System.IntPtr cmd);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetBroadcaster@SBCommandInterpreter@lldb@@QAE?AVSBBroadcaster@2@XZ")]
            internal static extern void GetBroadcaster_0(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?HasCommands@SBCommandInterpreter@lldb@@QAE_NXZ")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool HasCommands_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?HasAliases@SBCommandInterpreter@lldb@@QAE_NXZ")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool HasAliases_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?HasAliasOptions@SBCommandInterpreter@lldb@@QAE_NXZ")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool HasAliasOptions_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetProcess@SBCommandInterpreter@lldb@@QAE?AVSBProcess@2@XZ")]
            internal static extern void GetProcess_0(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetDebugger@SBCommandInterpreter@lldb@@QAE?AVSBDebugger@2@XZ")]
            internal static extern void GetDebugger_0(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?AddMultiwordCommand@SBCommandInterpreter@lldb@@QAE?AVSBCommand@2@PBD0@Z")]
            internal static extern void AddMultiwordCommand_0(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr name, global::System.IntPtr help);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?AddCommand@SBCommandInterpreter@lldb@@QAE?AVSBCommand@2@PBDPAVSBCommandPluginInterface@2@0@Z")]
            internal static extern void AddCommand_0(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr name, global::System.IntPtr impl, global::System.IntPtr help);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?SourceInitFileInHomeDirectory@SBCommandInterpreter@lldb@@QAEXAAVSBCommandReturnObject@2@@Z")]
            internal static extern void SourceInitFileInHomeDirectory_0(global::System.IntPtr instance, global::System.IntPtr result);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?SourceInitFileInCurrentWorkingDirectory@SBCommandInterpreter@lldb@@QAEXAAVSBCommandReturnObject@2@@Z")]
            internal static extern void SourceInitFileInCurrentWorkingDirectory_0(global::System.IntPtr instance, global::System.IntPtr result);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?HandleCommand@SBCommandInterpreter@lldb@@QAE?AW4ReturnStatus@2@PBDAAVSBCommandReturnObject@2@_N@Z")]
            internal static extern LLDB.ReturnStatus HandleCommand_0(global::System.IntPtr instance, global::System.IntPtr command_line, global::System.IntPtr result, bool add_to_history);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?HandleCommand@SBCommandInterpreter@lldb@@QAE?AW4ReturnStatus@2@PBDAAVSBExecutionContext@2@AAVSBCommandReturnObject@2@_N@Z")]
            internal static extern LLDB.ReturnStatus HandleCommand_1(global::System.IntPtr instance, global::System.IntPtr command_line, global::System.IntPtr exe_ctx, global::System.IntPtr result, bool add_to_history);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?HandleCommandsFromFile@SBCommandInterpreter@lldb@@QAEXAAVSBFileSpec@2@AAVSBExecutionContext@2@AAVSBCommandInterpreterRunOptions@2@VSBCommandReturnObject@2@@Z")]
            internal static extern void HandleCommandsFromFile_0(global::System.IntPtr instance, global::System.IntPtr file, global::System.IntPtr override_context, global::System.IntPtr options, LLDB.CommandReturnObject.Internal result);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?HandleCompletion@SBCommandInterpreter@lldb@@QAEHPBD00HHAAVSBStringList@2@@Z")]
            internal static extern int HandleCompletion_0(global::System.IntPtr instance, global::System.IntPtr current_line, global::System.IntPtr cursor, global::System.IntPtr last_char, int match_start_point, int max_return_elements, global::System.IntPtr matches);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?HandleCompletion@SBCommandInterpreter@lldb@@QAEHPBDIHHAAVSBStringList@2@@Z")]
            internal static extern int HandleCompletion_1(global::System.IntPtr instance, global::System.IntPtr current_line, uint cursor_pos, int match_start_point, int max_return_elements, global::System.IntPtr matches);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?SetCommandOverrideCallback@SBCommandInterpreter@lldb@@QAE_NPBDP6A_NPAXPAPBD@Z1@Z")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool SetCommandOverrideCallback_0(global::System.IntPtr instance, global::System.IntPtr command_name, global::System.IntPtr callback, global::System.IntPtr baton);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?IsActive@SBCommandInterpreter@lldb@@QAE_NXZ")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsActive_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetIOHandlerControlSequence@SBCommandInterpreter@lldb@@QAEPBDD@Z")]
            internal static extern global::System.IntPtr GetIOHandlerControlSequence_0(global::System.IntPtr instance, sbyte ch);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?ResolveCommand@SBCommandInterpreter@lldb@@QAEXPBDAAVSBCommandReturnObject@2@@Z")]
            internal static extern void ResolveCommand_0(global::System.IntPtr instance, global::System.IntPtr command_line, global::System.IntPtr result);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetBroadcasterClass@SBCommandInterpreter@lldb@@SAPBDXZ")]
            internal static extern global::System.IntPtr GetBroadcasterClass_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetPromptOnQuit@SBCommandInterpreter@lldb@@QAE_NXZ")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool GetPromptOnQuit_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?SetPromptOnQuit@SBCommandInterpreter@lldb@@QAEX_N@Z")]
            internal static extern void SetPromptOnQuit_0(global::System.IntPtr instance, bool b);
        }

        [Flags]
        public enum BroadcastBit
        {
            BroadcastBitThreadShouldExit = 1,
            BroadcastBitResetPrompt = 2,
            BroadcastBitQuitCommandReceived = 4,
            BroadcastBitAsynchronousOutputData = 8,
            BroadcastBitAsynchronousErrorData = 16
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, CommandInterpreter> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, CommandInterpreter>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        public static CommandInterpreter __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new CommandInterpreter(native.ToPointer(), skipVTables);
        }

        public static CommandInterpreter __CreateInstance(CommandInterpreter.Internal native, bool skipVTables = false)
        {
            return new CommandInterpreter(native, skipVTables);
        }

        private static void* __CopyValue(CommandInterpreter.Internal native)
        {
            var ret = Marshal.AllocHGlobal(4);
            LLDB.CommandInterpreter.Internal.cctor_0(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private CommandInterpreter(CommandInterpreter.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected CommandInterpreter(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public CommandInterpreter(LLDB.CommandInterpreter rhs)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(rhs, null))
                throw new global::System.ArgumentNullException("rhs", "Cannot be null because it is a C++ reference (&).");
            var arg0 = rhs.__Instance;
            Internal.cctor_0((__Instance + __PointerAdjustment), arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        protected virtual void Dispose(bool disposing)
        {
            LLDB.CommandInterpreter __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            Internal.dtor_0((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public bool IsValid()
        {
            var __ret = Internal.IsValid_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public bool CommandExists(string cmd)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(cmd);
            var __ret = Internal.CommandExists_0((__Instance + __PointerAdjustment), arg0);
            Marshal.FreeHGlobal(arg0);
            return __ret;
        }

        public bool AliasExists(string cmd)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(cmd);
            var __ret = Internal.AliasExists_0((__Instance + __PointerAdjustment), arg0);
            Marshal.FreeHGlobal(arg0);
            return __ret;
        }

        public LLDB.Broadcaster GetBroadcaster()
        {
            var __ret = new LLDB.Broadcaster.Internal();
            Internal.GetBroadcaster_0((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return LLDB.Broadcaster.__CreateInstance(__ret);
        }

        public bool HasCommands()
        {
            var __ret = Internal.HasCommands_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public bool HasAliases()
        {
            var __ret = Internal.HasAliases_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public bool HasAliasOptions()
        {
            var __ret = Internal.HasAliasOptions_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public LLDB.Process GetProcess()
        {
            var __ret = new LLDB.Process.Internal();
            Internal.GetProcess_0((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return LLDB.Process.__CreateInstance(__ret);
        }

        public LLDB.Debugger GetDebugger()
        {
            var __ret = new LLDB.Debugger.Internal();
            Internal.GetDebugger_0((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return LLDB.Debugger.__CreateInstance(__ret);
        }

        public LLDB.Command AddMultiwordCommand(string name, string help)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var arg1 = Marshal.StringToHGlobalAnsi(help);
            var __ret = new LLDB.Command.Internal();
            Internal.AddMultiwordCommand_0((__Instance + __PointerAdjustment), new IntPtr(&__ret), arg0, arg1);
            Marshal.FreeHGlobal(arg0);
            Marshal.FreeHGlobal(arg1);
            return LLDB.Command.__CreateInstance(__ret);
        }

        public LLDB.Command AddCommand(string name, LLDB.CommandPluginInterface impl, string help)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var arg1 = ReferenceEquals(impl, null) ? global::System.IntPtr.Zero : impl.__Instance;
            var arg2 = Marshal.StringToHGlobalAnsi(help);
            var __ret = new LLDB.Command.Internal();
            Internal.AddCommand_0((__Instance + __PointerAdjustment), new IntPtr(&__ret), arg0, arg1, arg2);
            Marshal.FreeHGlobal(arg0);
            Marshal.FreeHGlobal(arg2);
            return LLDB.Command.__CreateInstance(__ret);
        }

        public void SourceInitFileInHomeDirectory(LLDB.CommandReturnObject result)
        {
            if (ReferenceEquals(result, null))
                throw new global::System.ArgumentNullException("result", "Cannot be null because it is a C++ reference (&).");
            var arg0 = result.__Instance;
            Internal.SourceInitFileInHomeDirectory_0((__Instance + __PointerAdjustment), arg0);
        }

        public void SourceInitFileInCurrentWorkingDirectory(LLDB.CommandReturnObject result)
        {
            if (ReferenceEquals(result, null))
                throw new global::System.ArgumentNullException("result", "Cannot be null because it is a C++ reference (&).");
            var arg0 = result.__Instance;
            Internal.SourceInitFileInCurrentWorkingDirectory_0((__Instance + __PointerAdjustment), arg0);
        }

        public LLDB.ReturnStatus HandleCommand(string command_line, LLDB.CommandReturnObject result, bool add_to_history)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(command_line);
            if (ReferenceEquals(result, null))
                throw new global::System.ArgumentNullException("result", "Cannot be null because it is a C++ reference (&).");
            var arg1 = result.__Instance;
            var __ret = Internal.HandleCommand_0((__Instance + __PointerAdjustment), arg0, arg1, add_to_history);
            Marshal.FreeHGlobal(arg0);
            return __ret;
        }

        public LLDB.ReturnStatus HandleCommand(string command_line, LLDB.ExecutionContext exe_ctx, LLDB.CommandReturnObject result, bool add_to_history)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(command_line);
            if (ReferenceEquals(exe_ctx, null))
                throw new global::System.ArgumentNullException("exe_ctx", "Cannot be null because it is a C++ reference (&).");
            var arg1 = exe_ctx.__Instance;
            if (ReferenceEquals(result, null))
                throw new global::System.ArgumentNullException("result", "Cannot be null because it is a C++ reference (&).");
            var arg2 = result.__Instance;
            var __ret = Internal.HandleCommand_1((__Instance + __PointerAdjustment), arg0, arg1, arg2, add_to_history);
            Marshal.FreeHGlobal(arg0);
            return __ret;
        }

        public void HandleCommandsFromFile(LLDB.FileSpec file, LLDB.ExecutionContext override_context, LLDB.CommandInterpreterRunOptions options, LLDB.CommandReturnObject result)
        {
            if (ReferenceEquals(file, null))
                throw new global::System.ArgumentNullException("file", "Cannot be null because it is a C++ reference (&).");
            var arg0 = file.__Instance;
            if (ReferenceEquals(override_context, null))
                throw new global::System.ArgumentNullException("override_context", "Cannot be null because it is a C++ reference (&).");
            var arg1 = override_context.__Instance;
            if (ReferenceEquals(options, null))
                throw new global::System.ArgumentNullException("options", "Cannot be null because it is a C++ reference (&).");
            var arg2 = options.__Instance;
            var arg3 = ReferenceEquals(result, null) ? new LLDB.CommandReturnObject.Internal() : *(LLDB.CommandReturnObject.Internal*) (result.__Instance);
            Internal.HandleCommandsFromFile_0((__Instance + __PointerAdjustment), arg0, arg1, arg2, arg3);
        }

        public int HandleCompletion(string current_line, string cursor, string last_char, int match_start_point, int max_return_elements, LLDB.StringList matches)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(current_line);
            var arg1 = Marshal.StringToHGlobalAnsi(cursor);
            var arg2 = Marshal.StringToHGlobalAnsi(last_char);
            if (ReferenceEquals(matches, null))
                throw new global::System.ArgumentNullException("matches", "Cannot be null because it is a C++ reference (&).");
            var arg5 = matches.__Instance;
            var __ret = Internal.HandleCompletion_0((__Instance + __PointerAdjustment), arg0, arg1, arg2, match_start_point, max_return_elements, arg5);
            Marshal.FreeHGlobal(arg0);
            Marshal.FreeHGlobal(arg1);
            Marshal.FreeHGlobal(arg2);
            return __ret;
        }

        public int HandleCompletion(string current_line, uint cursor_pos, int match_start_point, int max_return_elements, LLDB.StringList matches)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(current_line);
            if (ReferenceEquals(matches, null))
                throw new global::System.ArgumentNullException("matches", "Cannot be null because it is a C++ reference (&).");
            var arg4 = matches.__Instance;
            var __ret = Internal.HandleCompletion_1((__Instance + __PointerAdjustment), arg0, cursor_pos, match_start_point, max_return_elements, arg4);
            Marshal.FreeHGlobal(arg0);
            return __ret;
        }

        public bool SetCommandOverrideCallback(string command_name, LLDB.CommandOverrideCallback callback, global::System.IntPtr baton)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(command_name);
            var arg1 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            var arg2 = baton;
            var __ret = Internal.SetCommandOverrideCallback_0((__Instance + __PointerAdjustment), arg0, arg1, arg2);
            Marshal.FreeHGlobal(arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Return true if the command interpreter is the active IO handler.</para>
        /// </summary>
        /// <remarks>
        /// <para>This indicates that any input coming into the debugger handles will</para>
        /// <para>go to the command interpreter and will result in LLDB command line</para>
        /// <para>commands being executed.</para>
        /// </remarks>
        public bool IsActive()
        {
            var __ret = Internal.IsActive_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        /// <summary>
        /// <para>Get the string that needs to be written to the debugger stdin file</para>
        /// <para>handle when a control character is typed.</para>
        /// </summary>
        /// <remarks>
        /// <para>Some GUI programs will intercept &quot;control + char&quot; sequences and want</para>
        /// <para>to have them do what normally would happen when using a real</para>
        /// <para>terminal, so this function allows GUI programs to emulate this</para>
        /// <para>functionality.</para>
        /// </remarks>
        /// <param name="ch">
        /// <para>The character that was typed along with the control key</para>
        /// </param>
        /// <returns>
        /// <para>The string that should be written into the file handle that is</para>
        /// <para>feeding the input stream for the debugger, or nullptr if there is</para>
        /// <para>no string for this control key.</para>
        /// </returns>
        public string GetIOHandlerControlSequence(sbyte ch)
        {
            var arg0 = ch;
            var __ret = Internal.GetIOHandlerControlSequence_0((__Instance + __PointerAdjustment), arg0);
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>
        /// <para>Resolve the command just as HandleCommand would, expanding abbreviations</para>
        /// <para>and aliases.  If successful, result-&gt;GetOutput has the full expansion.</para>
        /// </summary>
        public void ResolveCommand(string command_line, LLDB.CommandReturnObject result)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(command_line);
            if (ReferenceEquals(result, null))
                throw new global::System.ArgumentNullException("result", "Cannot be null because it is a C++ reference (&).");
            var arg1 = result.__Instance;
            Internal.ResolveCommand_0((__Instance + __PointerAdjustment), arg0, arg1);
            Marshal.FreeHGlobal(arg0);
        }

        public static string GetArgumentTypeAsCString(LLDB.CommandArgumentType arg_type)
        {
            var arg0 = arg_type;
            var __ret = Internal.GetArgumentTypeAsCString_0(arg0);
            return Marshal.PtrToStringAnsi(__ret);
        }

        public static string GetArgumentDescriptionAsCString(LLDB.CommandArgumentType arg_type)
        {
            var arg0 = arg_type;
            var __ret = Internal.GetArgumentDescriptionAsCString_0(arg0);
            return Marshal.PtrToStringAnsi(__ret);
        }

        public static bool EventIsCommandInterpreterEvent(LLDB.Event @event)
        {
            if (ReferenceEquals(@event, null))
                throw new global::System.ArgumentNullException("@event", "Cannot be null because it is a C++ reference (&).");
            var arg0 = @event.__Instance;
            var __ret = Internal.EventIsCommandInterpreterEvent_0(arg0);
            return __ret;
        }

        public static string BroadcasterClass
        {
            get
            {
                var __ret = Internal.GetBroadcasterClass_0();
                return Marshal.PtrToStringAnsi(__ret);
            }
        }

        public bool PromptOnQuit
        {
            get
            {
                var __ret = Internal.GetPromptOnQuit_0((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                Internal.SetPromptOnQuit_0((__Instance + __PointerAdjustment), value);
            }
        }
    }

    public unsafe partial class CommandPluginInterface : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0SBCommandPluginInterface@lldb@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0SBCommandPluginInterface@lldb@@QAE@ABV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, CommandPluginInterface> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, CommandPluginInterface>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        public static CommandPluginInterface __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new CommandPluginInterface(native.ToPointer(), skipVTables);
        }

        public static CommandPluginInterface __CreateInstance(CommandPluginInterface.Internal native, bool skipVTables = false)
        {
            return new CommandPluginInterface(native, skipVTables);
        }

        private static void* __CopyValue(CommandPluginInterface.Internal native)
        {
            var ret = Marshal.AllocHGlobal(4);
            LLDB.CommandPluginInterface.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private CommandPluginInterface(CommandPluginInterface.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected CommandPluginInterface(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };
            else
                SetupVTables(true);
        }

        public CommandPluginInterface()
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "lldb.LLDB.CommandPluginInterface");
        }

        public CommandPluginInterface(LLDB.CommandPluginInterface _0)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var arg0 = _0.__Instance;
            Internal.cctor_1((__Instance + __PointerAdjustment), arg0);
            SetupVTables(GetType().FullName == "lldb.LLDB.CommandPluginInterface");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        protected virtual void Dispose(bool disposing)
        {
            LLDB.CommandPluginInterface __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((Internal*) __Instance)->vfptr0 = new global::System.IntPtr(__OriginalVTables[0]);
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
            var ___dtor_0Delegate = (Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Action_IntPtr_int));
            ___dtor_0Delegate((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public virtual bool DoExecute(LLDB.Debugger _0, sbyte** _1, LLDB.CommandReturnObject _2)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 4);
            var ___DoExecute_0Delegate = (Delegates.Func_bool_IntPtr_LLDB_Debugger_Internal_sbytePtrPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Func_bool_IntPtr_LLDB_Debugger_Internal_sbytePtrPtr_IntPtr));
            var arg0 = ReferenceEquals(_0, null) ? new LLDB.Debugger.Internal() : *(LLDB.Debugger.Internal*) (_0.__Instance);
            var arg1 = _1;
            if (ReferenceEquals(_2, null))
                throw new global::System.ArgumentNullException("_2", "Cannot be null because it is a C++ reference (&).");
            var arg2 = _2.__Instance;
            var __ret = ___DoExecute_0Delegate((__Instance + __PointerAdjustment), arg0, arg1, arg2);
            return __ret;
        }

        #region Virtual table interop

        // virtual ~SBCommandPluginInterface() = default
        private static Delegates.Action_IntPtr_int _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (CommandPluginInterface) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(false);
        }

        // bool DoExecute (lldb::SBDebugger /*debugger*/, char** /*command*/, lldb::SBCommandReturnObject & /*result*/)
        private static Delegates.Func_bool_IntPtr_LLDB_Debugger_Internal_sbytePtrPtr_IntPtr _DoExecute_0DelegateInstance;

        private static bool _DoExecute_0DelegateHook(global::System.IntPtr instance, LLDB.Debugger.Internal _0, sbyte** _1, global::System.IntPtr _2)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (CommandPluginInterface) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            LLDB.CommandReturnObject __result2;
            if (_2 == IntPtr.Zero) __result2 = null;
            else if (LLDB.CommandReturnObject.NativeToManagedMap.ContainsKey(_2))
                __result2 = (LLDB.CommandReturnObject) LLDB.CommandReturnObject.NativeToManagedMap[_2];
            else __result2 = LLDB.CommandReturnObject.__CreateInstance(_2);
            var __ret = __target.DoExecute(LLDB.Debugger.__CreateInstance(_0), _1, __result2);
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            var native = (Internal*) __Instance.ToPointer();

            __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _DoExecute_0DelegateInstance += _DoExecute_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_DoExecute_0DelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(2 * 4);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + 0) = _Thunks[0];
                    *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                }

                native->vfptr0 = new IntPtr(__ManagedVTablesDtorOnly[0]);
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(2 * 4);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + 0) = _Thunks[0];
                    *(void**)(vfptr0 + 4) = _Thunks[1];
                }

                native->vfptr0 = new IntPtr(__ManagedVTables[0]);
            }
        }

        #endregion
    }

    public unsafe partial class Command : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0SBCommand@lldb@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0SBCommand@lldb@@QAE@ABV01@@Z")]
            internal static extern global::System.IntPtr cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??1SBCommand@lldb@@QAE@XZ")]
            internal static extern void dtor_0(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?IsValid@SBCommand@lldb@@QAE_NXZ")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsValid_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?AddMultiwordCommand@SBCommand@lldb@@QAE?AV12@PBD0@Z")]
            internal static extern void AddMultiwordCommand_0(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr name, global::System.IntPtr help);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?AddCommand@SBCommand@lldb@@QAE?AV12@PBDPAVSBCommandPluginInterface@2@0@Z")]
            internal static extern void AddCommand_0(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr name, global::System.IntPtr impl, global::System.IntPtr help);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetName@SBCommand@lldb@@QAEPBDXZ")]
            internal static extern global::System.IntPtr GetName_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetHelp@SBCommand@lldb@@QAEPBDXZ")]
            internal static extern global::System.IntPtr GetHelp_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?SetHelp@SBCommand@lldb@@QAEXPBD@Z")]
            internal static extern void SetHelp_0(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetHelpLong@SBCommand@lldb@@QAEPBDXZ")]
            internal static extern global::System.IntPtr GetHelpLong_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?SetHelpLong@SBCommand@lldb@@QAEXPBD@Z")]
            internal static extern void SetHelpLong_0(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetFlags@SBCommand@lldb@@QAEIXZ")]
            internal static extern uint GetFlags_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?SetFlags@SBCommand@lldb@@QAEXI@Z")]
            internal static extern void SetFlags_0(global::System.IntPtr instance, uint flags);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Command> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Command>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        public static Command __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new Command(native.ToPointer(), skipVTables);
        }

        public static Command __CreateInstance(Command.Internal native, bool skipVTables = false)
        {
            return new Command(native, skipVTables);
        }

        private static void* __CopyValue(Command.Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            LLDB.Command.Internal.cctor_3(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Command(Command.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Command(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Command()
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            Internal.ctor_0((__Instance + __PointerAdjustment));
        }

        public Command(LLDB.Command _0)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var arg0 = _0.__Instance;
            Internal.cctor_3((__Instance + __PointerAdjustment), arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        protected virtual void Dispose(bool disposing)
        {
            LLDB.Command __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            Internal.dtor_0((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public bool IsValid()
        {
            var __ret = Internal.IsValid_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public LLDB.Command AddMultiwordCommand(string name, string help)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var arg1 = Marshal.StringToHGlobalAnsi(help);
            var __ret = new LLDB.Command.Internal();
            Internal.AddMultiwordCommand_0((__Instance + __PointerAdjustment), new IntPtr(&__ret), arg0, arg1);
            Marshal.FreeHGlobal(arg0);
            Marshal.FreeHGlobal(arg1);
            return LLDB.Command.__CreateInstance(__ret);
        }

        public LLDB.Command AddCommand(string name, LLDB.CommandPluginInterface impl, string help)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var arg1 = ReferenceEquals(impl, null) ? global::System.IntPtr.Zero : impl.__Instance;
            var arg2 = Marshal.StringToHGlobalAnsi(help);
            var __ret = new LLDB.Command.Internal();
            Internal.AddCommand_0((__Instance + __PointerAdjustment), new IntPtr(&__ret), arg0, arg1, arg2);
            Marshal.FreeHGlobal(arg0);
            Marshal.FreeHGlobal(arg2);
            return LLDB.Command.__CreateInstance(__ret);
        }

        public string Name
        {
            get
            {
                var __ret = Internal.GetName_0((__Instance + __PointerAdjustment));
                return Marshal.PtrToStringAnsi(__ret);
            }
        }

        public string Help
        {
            get
            {
                var __ret = Internal.GetHelp_0((__Instance + __PointerAdjustment));
                return Marshal.PtrToStringAnsi(__ret);
            }

            set
            {
                var arg0 = Marshal.StringToHGlobalAnsi(value);
                Internal.SetHelp_0((__Instance + __PointerAdjustment), arg0);
                Marshal.FreeHGlobal(arg0);
            }
        }

        public string HelpLong
        {
            get
            {
                var __ret = Internal.GetHelpLong_0((__Instance + __PointerAdjustment));
                return Marshal.PtrToStringAnsi(__ret);
            }

            set
            {
                var arg0 = Marshal.StringToHGlobalAnsi(value);
                Internal.SetHelpLong_0((__Instance + __PointerAdjustment), arg0);
                Marshal.FreeHGlobal(arg0);
            }
        }

        public uint Flags
        {
            get
            {
                var __ret = Internal.GetFlags_0((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                Internal.SetFlags_0((__Instance + __PointerAdjustment), value);
            }
        }
    }
}
