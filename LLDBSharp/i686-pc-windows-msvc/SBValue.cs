//----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace LLDB
{
    public unsafe partial class Value : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0SBValue@lldb@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0SBValue@lldb@@QAE@ABV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr rhs);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??1SBValue@lldb@@QAE@XZ")]
            internal static extern void dtor_0(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?IsValid@SBValue@lldb@@QAE_NXZ")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsValid_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?Clear@SBValue@lldb@@QAEXXZ")]
            internal static extern void Clear_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetError@SBValue@lldb@@QAE?AVSBError@2@XZ")]
            internal static extern void GetError_0(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?IsInScope@SBValue@lldb@@QAE_NXZ")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsInScope_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetValueAsSigned@SBValue@lldb@@QAE_JAAVSBError@2@_J@Z")]
            internal static extern long GetValueAsSigned_0(global::System.IntPtr instance, global::System.IntPtr error, long fail_value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetValueAsUnsigned@SBValue@lldb@@QAE_KAAVSBError@2@_K@Z")]
            internal static extern ulong GetValueAsUnsigned_0(global::System.IntPtr instance, global::System.IntPtr error, ulong fail_value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetValueAsSigned@SBValue@lldb@@QAE_J_J@Z")]
            internal static extern long GetValueAsSigned_1(global::System.IntPtr instance, long fail_value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetValueAsUnsigned@SBValue@lldb@@QAE_K_K@Z")]
            internal static extern ulong GetValueAsUnsigned_1(global::System.IntPtr instance, ulong fail_value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetSummary@SBValue@lldb@@QAEPBDAAVSBStream@2@AAVSBTypeSummaryOptions@2@@Z")]
            internal static extern global::System.IntPtr GetSummary_1(global::System.IntPtr instance, global::System.IntPtr stream, global::System.IntPtr options);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetDynamicValue@SBValue@lldb@@QAE?AV12@W4DynamicValueType@2@@Z")]
            internal static extern void GetDynamicValue_0(global::System.IntPtr instance, global::System.IntPtr @return, LLDB.DynamicValueType use_dynamic);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetStaticValue@SBValue@lldb@@QAE?AV12@XZ")]
            internal static extern void GetStaticValue_0(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetNonSyntheticValue@SBValue@lldb@@QAE?AV12@XZ")]
            internal static extern void GetNonSyntheticValue_0(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?IsDynamic@SBValue@lldb@@QAE_NXZ")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsDynamic_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?IsSynthetic@SBValue@lldb@@QAE_NXZ")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsSynthetic_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?SetValueFromCString@SBValue@lldb@@QAE_NPBD@Z")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool SetValueFromCString_0(global::System.IntPtr instance, global::System.IntPtr value_str);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?SetValueFromCString@SBValue@lldb@@QAE_NPBDAAVSBError@2@@Z")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool SetValueFromCString_1(global::System.IntPtr instance, global::System.IntPtr value_str, global::System.IntPtr error);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetTypeFormat@SBValue@lldb@@QAE?AVSBTypeFormat@2@XZ")]
            internal static extern void GetTypeFormat_0(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetTypeSummary@SBValue@lldb@@QAE?AVSBTypeSummary@2@XZ")]
            internal static extern void GetTypeSummary_0(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetTypeFilter@SBValue@lldb@@QAE?AVSBTypeFilter@2@XZ")]
            internal static extern void GetTypeFilter_0(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetTypeSynthetic@SBValue@lldb@@QAE?AVSBTypeSynthetic@2@XZ")]
            internal static extern void GetTypeSynthetic_0(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetChildAtIndex@SBValue@lldb@@QAE?AV12@I@Z")]
            internal static extern void GetChildAtIndex_0(global::System.IntPtr instance, global::System.IntPtr @return, uint idx);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?CreateChildAtOffset@SBValue@lldb@@QAE?AV12@PBDIVSBType@2@@Z")]
            internal static extern LLDB.Value.Internal CreateChildAtOffset_0(global::System.IntPtr instance, global::System.IntPtr name, uint offset, LLDB.Type.Internal type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?Cast@SBValue@lldb@@QAE?AV12@VSBType@2@@Z")]
            internal static extern LLDB.Value.Internal Cast_0(global::System.IntPtr instance, LLDB.Type.Internal type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?CreateValueFromExpression@SBValue@lldb@@QAE?AV12@PBD0@Z")]
            internal static extern void CreateValueFromExpression_0(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr name, global::System.IntPtr expression);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?CreateValueFromExpression@SBValue@lldb@@QAE?AV12@PBD0AAVSBExpressionOptions@2@@Z")]
            internal static extern void CreateValueFromExpression_1(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr name, global::System.IntPtr expression, global::System.IntPtr options);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?CreateValueFromAddress@SBValue@lldb@@QAE?AV12@PBD_KVSBType@2@@Z")]
            internal static extern LLDB.Value.Internal CreateValueFromAddress_0(global::System.IntPtr instance, global::System.IntPtr name, ulong address, LLDB.Type.Internal type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?CreateValueFromData@SBValue@lldb@@QAE?AV12@PBDVSBData@2@VSBType@2@@Z")]
            internal static extern LLDB.Value.Internal CreateValueFromData_0(global::System.IntPtr instance, global::System.IntPtr name, LLDB.Data.Internal data, LLDB.Type.Internal type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetChildAtIndex@SBValue@lldb@@QAE?AV12@IW4DynamicValueType@2@_N@Z")]
            internal static extern void GetChildAtIndex_1(global::System.IntPtr instance, global::System.IntPtr @return, uint idx, LLDB.DynamicValueType use_dynamic, bool can_create_synthetic);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetIndexOfChildWithName@SBValue@lldb@@QAEIPBD@Z")]
            internal static extern uint GetIndexOfChildWithName_0(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetChildMemberWithName@SBValue@lldb@@QAE?AV12@PBD@Z")]
            internal static extern void GetChildMemberWithName_0(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetChildMemberWithName@SBValue@lldb@@QAE?AV12@PBDW4DynamicValueType@2@@Z")]
            internal static extern void GetChildMemberWithName_1(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr name, LLDB.DynamicValueType use_dynamic);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetValueForExpressionPath@SBValue@lldb@@QAE?AV12@PBD@Z")]
            internal static extern void GetValueForExpressionPath_0(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr expr_path);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?AddressOf@SBValue@lldb@@QAE?AV12@XZ")]
            internal static extern void AddressOf_0(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetAddress@SBValue@lldb@@QAE?AVSBAddress@2@XZ")]
            internal static extern void GetAddress_0(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetPointeeData@SBValue@lldb@@QAE?AVSBData@2@II@Z")]
            internal static extern void GetPointeeData_0(global::System.IntPtr instance, global::System.IntPtr @return, uint item_idx, uint item_count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetData@SBValue@lldb@@QAE?AVSBData@2@XZ")]
            internal static extern void GetData_0(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?SetData@SBValue@lldb@@QAE_NAAVSBData@2@AAVSBError@2@@Z")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool SetData_0(global::System.IntPtr instance, global::System.IntPtr data, global::System.IntPtr error);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetDeclaration@SBValue@lldb@@QAE?AVSBDeclaration@2@XZ")]
            internal static extern void GetDeclaration_0(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?MightHaveChildren@SBValue@lldb@@QAE_NXZ")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool MightHaveChildren_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?IsRuntimeSupportValue@SBValue@lldb@@QAE_NXZ")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsRuntimeSupportValue_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetNumChildren@SBValue@lldb@@QAEII@Z")]
            internal static extern uint GetNumChildren_1(global::System.IntPtr instance, uint max);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetTarget@SBValue@lldb@@QAE?AVSBTarget@2@XZ")]
            internal static extern void GetTarget_0(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetProcess@SBValue@lldb@@QAE?AVSBProcess@2@XZ")]
            internal static extern void GetProcess_0(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetThread@SBValue@lldb@@QAE?AVSBThread@2@XZ")]
            internal static extern void GetThread_0(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetFrame@SBValue@lldb@@QAE?AVSBFrame@2@XZ")]
            internal static extern void GetFrame_0(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?Dereference@SBValue@lldb@@QAE?AV12@XZ")]
            internal static extern void Dereference_0(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?TypeIsPointerType@SBValue@lldb@@QAE_NXZ")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool TypeIsPointerType_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetType@SBValue@lldb@@QAE?AVSBType@2@XZ")]
            internal static extern void GetType_0(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?Persist@SBValue@lldb@@QAE?AV12@XZ")]
            internal static extern void Persist_0(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetDescription@SBValue@lldb@@QAE_NAAVSBStream@2@@Z")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool GetDescription_0(global::System.IntPtr instance, global::System.IntPtr description);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetExpressionPath@SBValue@lldb@@QAE_NAAVSBStream@2@@Z")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool GetExpressionPath_0(global::System.IntPtr instance, global::System.IntPtr description);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetExpressionPath@SBValue@lldb@@QAE_NAAVSBStream@2@_N@Z")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool GetExpressionPath_1(global::System.IntPtr instance, global::System.IntPtr description, bool qualify_cxx_base_classes);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?Watch@SBValue@lldb@@QAE?AVSBWatchpoint@2@_N00AAVSBError@2@@Z")]
            internal static extern void Watch_0(global::System.IntPtr instance, global::System.IntPtr @return, bool resolve_location, bool read, bool write, global::System.IntPtr error);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?Watch@SBValue@lldb@@QAE?AVSBWatchpoint@2@_N00@Z")]
            internal static extern void Watch_1(global::System.IntPtr instance, global::System.IntPtr @return, bool resolve_location, bool read, bool write);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?WatchPointee@SBValue@lldb@@QAE?AVSBWatchpoint@2@_N00AAVSBError@2@@Z")]
            internal static extern void WatchPointee_0(global::System.IntPtr instance, global::System.IntPtr @return, bool resolve_location, bool read, bool write, global::System.IntPtr error);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetID@SBValue@lldb@@QAE_KXZ")]
            internal static extern ulong GetID_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetName@SBValue@lldb@@QAEPBDXZ")]
            internal static extern global::System.IntPtr GetName_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetTypeName@SBValue@lldb@@QAEPBDXZ")]
            internal static extern global::System.IntPtr GetTypeName_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetDisplayTypeName@SBValue@lldb@@QAEPBDXZ")]
            internal static extern global::System.IntPtr GetDisplayTypeName_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetByteSize@SBValue@lldb@@QAEIXZ")]
            internal static extern uint GetByteSize_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetFormat@SBValue@lldb@@QAE?AW4Format@2@XZ")]
            internal static extern LLDB.Format GetFormat_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?SetFormat@SBValue@lldb@@QAEXW4Format@2@@Z")]
            internal static extern void SetFormat_0(global::System.IntPtr instance, LLDB.Format format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetValue@SBValue@lldb@@QAEPBDXZ")]
            internal static extern global::System.IntPtr GetValueAsString_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetValueType@SBValue@lldb@@QAE?AW4ValueType@2@XZ")]
            internal static extern LLDB.ValueType GetValueType_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetValueDidChange@SBValue@lldb@@QAE_NXZ")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool GetValueDidChange_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetSummary@SBValue@lldb@@QAEPBDXZ")]
            internal static extern global::System.IntPtr GetSummary_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetObjectDescription@SBValue@lldb@@QAEPBDXZ")]
            internal static extern global::System.IntPtr GetObjectDescription_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetTypeValidatorResult@SBValue@lldb@@QAEPBDXZ")]
            internal static extern global::System.IntPtr GetTypeValidatorResult_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetPreferDynamicValue@SBValue@lldb@@QAE?AW4DynamicValueType@2@XZ")]
            internal static extern LLDB.DynamicValueType GetPreferDynamicValue_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?SetPreferDynamicValue@SBValue@lldb@@QAEXW4DynamicValueType@2@@Z")]
            internal static extern void SetPreferDynamicValue_0(global::System.IntPtr instance, LLDB.DynamicValueType use_dynamic);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetPreferSyntheticValue@SBValue@lldb@@QAE_NXZ")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool GetPreferSyntheticValue_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?SetPreferSyntheticValue@SBValue@lldb@@QAEX_N@Z")]
            internal static extern void SetPreferSyntheticValue_0(global::System.IntPtr instance, bool use_synthetic);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetLocation@SBValue@lldb@@QAEPBDXZ")]
            internal static extern global::System.IntPtr GetLocation_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetLoadAddress@SBValue@lldb@@QAE_KXZ")]
            internal static extern ulong GetLoadAddress_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetNumChildren@SBValue@lldb@@QAEIXZ")]
            internal static extern uint GetNumChildren_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetOpaqueType@SBValue@lldb@@QAEPAXXZ")]
            internal static extern global::System.IntPtr GetOpaqueType_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Value> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Value>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        public static Value __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new Value(native.ToPointer(), skipVTables);
        }

        public static Value __CreateInstance(Value.Internal native, bool skipVTables = false)
        {
            return new Value(native, skipVTables);
        }

        private static void* __CopyValue(Value.Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            LLDB.Value.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Value(Value.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Value(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Value()
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            Internal.ctor_0((__Instance + __PointerAdjustment));
        }

        public Value(LLDB.Value rhs)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(rhs, null))
                throw new global::System.ArgumentNullException("rhs", "Cannot be null because it is a C++ reference (&).");
            var arg0 = rhs.__Instance;
            Internal.cctor_1((__Instance + __PointerAdjustment), arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        protected virtual void Dispose(bool disposing)
        {
            LLDB.Value __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            Internal.dtor_0((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public bool IsValid()
        {
            var __ret = Internal.IsValid_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public void Clear()
        {
            Internal.Clear_0((__Instance + __PointerAdjustment));
        }

        public LLDB.Error GetError()
        {
            var __ret = new LLDB.Error.Internal();
            Internal.GetError_0((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return LLDB.Error.__CreateInstance(__ret);
        }

        public bool IsInScope()
        {
            var __ret = Internal.IsInScope_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public long GetValueAsSigned(LLDB.Error error, long fail_value)
        {
            if (ReferenceEquals(error, null))
                throw new global::System.ArgumentNullException("error", "Cannot be null because it is a C++ reference (&).");
            var arg0 = error.__Instance;
            var __ret = Internal.GetValueAsSigned_0((__Instance + __PointerAdjustment), arg0, fail_value);
            return __ret;
        }

        public ulong GetValueAsUnsigned(LLDB.Error error, ulong fail_value)
        {
            if (ReferenceEquals(error, null))
                throw new global::System.ArgumentNullException("error", "Cannot be null because it is a C++ reference (&).");
            var arg0 = error.__Instance;
            var __ret = Internal.GetValueAsUnsigned_0((__Instance + __PointerAdjustment), arg0, fail_value);
            return __ret;
        }

        public long GetValueAsSigned(long fail_value)
        {
            var __ret = Internal.GetValueAsSigned_1((__Instance + __PointerAdjustment), fail_value);
            return __ret;
        }

        public ulong GetValueAsUnsigned(ulong fail_value)
        {
            var __ret = Internal.GetValueAsUnsigned_1((__Instance + __PointerAdjustment), fail_value);
            return __ret;
        }

        public string GetSummary(LLDB.Stream stream, LLDB.TypeSummaryOptions options)
        {
            if (ReferenceEquals(stream, null))
                throw new global::System.ArgumentNullException("stream", "Cannot be null because it is a C++ reference (&).");
            var arg0 = stream.__Instance;
            if (ReferenceEquals(options, null))
                throw new global::System.ArgumentNullException("options", "Cannot be null because it is a C++ reference (&).");
            var arg1 = options.__Instance;
            var __ret = Internal.GetSummary_1((__Instance + __PointerAdjustment), arg0, arg1);
            return Marshal.PtrToStringAnsi(__ret);
        }

        public LLDB.Value GetDynamicValue(LLDB.DynamicValueType use_dynamic)
        {
            var arg0 = use_dynamic;
            var __ret = new LLDB.Value.Internal();
            Internal.GetDynamicValue_0((__Instance + __PointerAdjustment), new IntPtr(&__ret), arg0);
            return LLDB.Value.__CreateInstance(__ret);
        }

        public LLDB.Value GetStaticValue()
        {
            var __ret = new LLDB.Value.Internal();
            Internal.GetStaticValue_0((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return LLDB.Value.__CreateInstance(__ret);
        }

        public LLDB.Value GetNonSyntheticValue()
        {
            var __ret = new LLDB.Value.Internal();
            Internal.GetNonSyntheticValue_0((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return LLDB.Value.__CreateInstance(__ret);
        }

        public bool IsDynamic()
        {
            var __ret = Internal.IsDynamic_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public bool IsSynthetic()
        {
            var __ret = Internal.IsSynthetic_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public bool SetValueFromCString(string value_str)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(value_str);
            var __ret = Internal.SetValueFromCString_0((__Instance + __PointerAdjustment), arg0);
            Marshal.FreeHGlobal(arg0);
            return __ret;
        }

        public bool SetValueFromCString(string value_str, LLDB.Error error)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(value_str);
            if (ReferenceEquals(error, null))
                throw new global::System.ArgumentNullException("error", "Cannot be null because it is a C++ reference (&).");
            var arg1 = error.__Instance;
            var __ret = Internal.SetValueFromCString_1((__Instance + __PointerAdjustment), arg0, arg1);
            Marshal.FreeHGlobal(arg0);
            return __ret;
        }

        public LLDB.TypeFormat GetTypeFormat()
        {
            var __ret = new LLDB.TypeFormat.Internal();
            Internal.GetTypeFormat_0((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return LLDB.TypeFormat.__CreateInstance(__ret);
        }

        public LLDB.TypeSummary GetTypeSummary()
        {
            var __ret = new LLDB.TypeSummary.Internal();
            Internal.GetTypeSummary_0((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return LLDB.TypeSummary.__CreateInstance(__ret);
        }

        public LLDB.TypeFilter GetTypeFilter()
        {
            var __ret = new LLDB.TypeFilter.Internal();
            Internal.GetTypeFilter_0((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return LLDB.TypeFilter.__CreateInstance(__ret);
        }

        public LLDB.TypeSynthetic GetTypeSynthetic()
        {
            var __ret = new LLDB.TypeSynthetic.Internal();
            Internal.GetTypeSynthetic_0((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return LLDB.TypeSynthetic.__CreateInstance(__ret);
        }

        public LLDB.Value GetChildAtIndex(uint idx)
        {
            var __ret = new LLDB.Value.Internal();
            Internal.GetChildAtIndex_0((__Instance + __PointerAdjustment), new IntPtr(&__ret), idx);
            return LLDB.Value.__CreateInstance(__ret);
        }

        public LLDB.Value CreateChildAtOffset(string name, uint offset, LLDB.Type type)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var arg2 = ReferenceEquals(type, null) ? new LLDB.Type.Internal() : *(LLDB.Type.Internal*) (type.__Instance);
            var __ret = Internal.CreateChildAtOffset_0((__Instance + __PointerAdjustment), arg0, offset, arg2);
            Marshal.FreeHGlobal(arg0);
            return LLDB.Value.__CreateInstance(__ret);
        }

        public LLDB.Value Cast(LLDB.Type type)
        {
            var arg0 = ReferenceEquals(type, null) ? new LLDB.Type.Internal() : *(LLDB.Type.Internal*) (type.__Instance);
            var __ret = Internal.Cast_0((__Instance + __PointerAdjustment), arg0);
            return LLDB.Value.__CreateInstance(__ret);
        }

        public LLDB.Value CreateValueFromExpression(string name, string expression)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var arg1 = Marshal.StringToHGlobalAnsi(expression);
            var __ret = new LLDB.Value.Internal();
            Internal.CreateValueFromExpression_0((__Instance + __PointerAdjustment), new IntPtr(&__ret), arg0, arg1);
            Marshal.FreeHGlobal(arg0);
            Marshal.FreeHGlobal(arg1);
            return LLDB.Value.__CreateInstance(__ret);
        }

        public LLDB.Value CreateValueFromExpression(string name, string expression, LLDB.ExpressionOptions options)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var arg1 = Marshal.StringToHGlobalAnsi(expression);
            if (ReferenceEquals(options, null))
                throw new global::System.ArgumentNullException("options", "Cannot be null because it is a C++ reference (&).");
            var arg2 = options.__Instance;
            var __ret = new LLDB.Value.Internal();
            Internal.CreateValueFromExpression_1((__Instance + __PointerAdjustment), new IntPtr(&__ret), arg0, arg1, arg2);
            Marshal.FreeHGlobal(arg0);
            Marshal.FreeHGlobal(arg1);
            return LLDB.Value.__CreateInstance(__ret);
        }

        public LLDB.Value CreateValueFromAddress(string name, ulong address, LLDB.Type type)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var arg2 = ReferenceEquals(type, null) ? new LLDB.Type.Internal() : *(LLDB.Type.Internal*) (type.__Instance);
            var __ret = Internal.CreateValueFromAddress_0((__Instance + __PointerAdjustment), arg0, address, arg2);
            Marshal.FreeHGlobal(arg0);
            return LLDB.Value.__CreateInstance(__ret);
        }

        public LLDB.Value CreateValueFromData(string name, LLDB.Data data, LLDB.Type type)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var arg1 = ReferenceEquals(data, null) ? new LLDB.Data.Internal() : *(LLDB.Data.Internal*) (data.__Instance);
            var arg2 = ReferenceEquals(type, null) ? new LLDB.Type.Internal() : *(LLDB.Type.Internal*) (type.__Instance);
            var __ret = Internal.CreateValueFromData_0((__Instance + __PointerAdjustment), arg0, arg1, arg2);
            Marshal.FreeHGlobal(arg0);
            return LLDB.Value.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Get a child value by index from a value.</para>
        /// </summary>
        /// <remarks>
        /// <para>Structs, unions, classes, arrays and pointers have child</para>
        /// <para>values that can be access by index. </para>
        /// <para>Structs and unions access child members using a zero based index</para>
        /// <para>for each child member. For</para>
        /// <para>Classes reserve the first indexes for base classes that have </para>
        /// <para>members (empty base classes are omitted), and all members of the</para>
        /// <para>current class will then follow the base classes. </para>
        /// <para>Pointers differ depending on what they point to. If the pointer</para>
        /// <para>points to a simple type, the child at index zero</para>
        /// <para>is the only child value available, unless </para>
        /// <para> </para>
        /// <para>is </para>
        /// <para>in which case the pointer will be used as an array</para>
        /// <para>and can create 'synthetic' child values using positive or </para>
        /// <para>negative indexes. If the pointer points to an aggregate type </para>
        /// <para>(an array, class, union, struct), then the pointee is </para>
        /// <para>transparently skipped and any children are going to be the indexes</para>
        /// <para>of the child values within the aggregate type. For example if</para>
        /// <para>we have a 'Point' type and we have a SBValue that contains a</para>
        /// <para>pointer to a 'Point' type, then the child at index zero will be</para>
        /// <para>the 'x' member, and the child at index 1 will be the 'y' member</para>
        /// <para>(the child at index zero won't be a 'Point' instance).</para>
        /// <para>If you actually need an SBValue that represents the type pointed</para>
        /// <para>to by a SBValue for which GetType().IsPointeeType() returns true,</para>
        /// <para>regardless of the pointee type, you can do that with SBValue::Dereference.</para>
        /// <para>Arrays have a preset number of children that can be accessed by</para>
        /// <para>index and will returns invalid child values for indexes that are</para>
        /// <para>out of bounds unless the </para>
        /// <para>is </para>
        /// <para>In this</para>
        /// <para>case the array can create 'synthetic' child values for indexes </para>
        /// <para>that aren't in the array bounds using positive or negative </para>
        /// <para>indexes.</para>
        /// </remarks>
        /// <param name="idx">
        /// <para>The index of the child value to get</para>
        /// </param>
        /// <param name="use_dynamic">
        /// <para>An enumeration that specifies whether to get dynamic values,</para>
        /// <para>and also if the target can be run to figure out the dynamic</para>
        /// <para>type of the child value.</para>
        /// </param>
        /// <param name="can_create_synthetic">
        /// <para>If</para>
        /// <para>then allow child values to be created by index</para>
        /// <para>for pointers and arrays for indexes that normally wouldn't</para>
        /// <para>be allowed.</para>
        /// </param>
        /// <returns>
        /// <para>A new SBValue object that represents the child member value.</para>
        /// </returns>
        public LLDB.Value GetChildAtIndex(uint idx, LLDB.DynamicValueType use_dynamic, bool can_create_synthetic)
        {
            var arg1 = use_dynamic;
            var __ret = new LLDB.Value.Internal();
            Internal.GetChildAtIndex_1((__Instance + __PointerAdjustment), new IntPtr(&__ret), idx, arg1, can_create_synthetic);
            return LLDB.Value.__CreateInstance(__ret);
        }

        public uint GetIndexOfChildWithName(string name)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var __ret = Internal.GetIndexOfChildWithName_0((__Instance + __PointerAdjustment), arg0);
            Marshal.FreeHGlobal(arg0);
            return __ret;
        }

        public LLDB.Value GetChildMemberWithName(string name)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var __ret = new LLDB.Value.Internal();
            Internal.GetChildMemberWithName_0((__Instance + __PointerAdjustment), new IntPtr(&__ret), arg0);
            Marshal.FreeHGlobal(arg0);
            return LLDB.Value.__CreateInstance(__ret);
        }

        public LLDB.Value GetChildMemberWithName(string name, LLDB.DynamicValueType use_dynamic)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var arg1 = use_dynamic;
            var __ret = new LLDB.Value.Internal();
            Internal.GetChildMemberWithName_1((__Instance + __PointerAdjustment), new IntPtr(&__ret), arg0, arg1);
            Marshal.FreeHGlobal(arg0);
            return LLDB.Value.__CreateInstance(__ret);
        }

        public LLDB.Value GetValueForExpressionPath(string expr_path)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(expr_path);
            var __ret = new LLDB.Value.Internal();
            Internal.GetValueForExpressionPath_0((__Instance + __PointerAdjustment), new IntPtr(&__ret), arg0);
            Marshal.FreeHGlobal(arg0);
            return LLDB.Value.__CreateInstance(__ret);
        }

        public LLDB.Value AddressOf()
        {
            var __ret = new LLDB.Value.Internal();
            Internal.AddressOf_0((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return LLDB.Value.__CreateInstance(__ret);
        }

        public LLDB.Address GetAddress()
        {
            var __ret = new LLDB.Address.Internal();
            Internal.GetAddress_0((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return LLDB.Address.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Get an SBData wrapping what this SBValue points to.</para>
        /// </summary>
        /// <remarks>
        /// <para>This method will dereference the current SBValue, if its</para>
        /// <para>data type is a T* or T[], and extract item_count elements</para>
        /// <para>of type T from it, copying their contents in an SBData. </para>
        /// </remarks>
        /// <param name="item_idx">
        /// <para>The index of the first item to retrieve. For an array</para>
        /// <para>this is equivalent to array[item_idx], for a pointer</para>
        /// <para>to *(pointer + item_idx). In either case, the measurement</para>
        /// <para>unit for item_idx is the sizeof(T) rather than the byte</para>
        /// </param>
        /// <param name="item_count">
        /// <para>How many items should be copied into the output. By default</para>
        /// <para>only one item is copied, but more can be asked for.</para>
        /// </param>
        /// <returns>
        /// <para>An SBData with the contents of the copied items, on success.</para>
        /// <para>An empty SBData otherwise.</para>
        /// </returns>
        public LLDB.Data GetPointeeData(uint item_idx, uint item_count)
        {
            var __ret = new LLDB.Data.Internal();
            Internal.GetPointeeData_0((__Instance + __PointerAdjustment), new IntPtr(&__ret), item_idx, item_count);
            return LLDB.Data.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Get an SBData wrapping the contents of this SBValue.</para>
        /// </summary>
        /// <remarks>
        /// <para>This method will read the contents of this object in memory</para>
        /// <para>and copy them into an SBData for future use. </para>
        /// </remarks>
        /// <returns>
        /// <para>An SBData with the contents of this SBValue, on success.</para>
        /// <para>An empty SBData otherwise.</para>
        /// </returns>
        public LLDB.Data GetData()
        {
            var __ret = new LLDB.Data.Internal();
            Internal.GetData_0((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return LLDB.Data.__CreateInstance(__ret);
        }

        public bool SetData(LLDB.Data data, LLDB.Error error)
        {
            if (ReferenceEquals(data, null))
                throw new global::System.ArgumentNullException("data", "Cannot be null because it is a C++ reference (&).");
            var arg0 = data.__Instance;
            if (ReferenceEquals(error, null))
                throw new global::System.ArgumentNullException("error", "Cannot be null because it is a C++ reference (&).");
            var arg1 = error.__Instance;
            var __ret = Internal.SetData_0((__Instance + __PointerAdjustment), arg0, arg1);
            return __ret;
        }

        public LLDB.Declaration GetDeclaration()
        {
            var __ret = new LLDB.Declaration.Internal();
            Internal.GetDeclaration_0((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return LLDB.Declaration.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Find out if a SBValue might have children.</para>
        /// </summary>
        /// <remarks>
        /// <para>This call is much more efficient than GetNumChildren() as it</para>
        /// <para>doesn't need to complete the underlying type. This is designed</para>
        /// <para>to be used in a UI environment in order to detect if the</para>
        /// <para>disclosure triangle should be displayed or not.</para>
        /// <para>This function returns true for class, union, structure,</para>
        /// <para>pointers, references, arrays and more. Again, it does so without</para>
        /// <para>doing any expensive type completion.</para>
        /// </remarks>
        /// <returns>
        /// <para>Returns</para>
        /// <para>if the SBValue might have children, or</para>
        /// <para>otherwise.</para>
        /// </returns>
        public bool MightHaveChildren()
        {
            var __ret = Internal.MightHaveChildren_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public bool IsRuntimeSupportValue()
        {
            var __ret = Internal.IsRuntimeSupportValue_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public uint GetNumChildren(uint max)
        {
            var __ret = Internal.GetNumChildren_1((__Instance + __PointerAdjustment), max);
            return __ret;
        }

        public LLDB.Target GetTarget()
        {
            var __ret = new LLDB.Target.Internal();
            Internal.GetTarget_0((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return LLDB.Target.__CreateInstance(__ret);
        }

        public LLDB.Process GetProcess()
        {
            var __ret = new LLDB.Process.Internal();
            Internal.GetProcess_0((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return LLDB.Process.__CreateInstance(__ret);
        }

        public LLDB.Thread GetThread()
        {
            var __ret = new LLDB.Thread.Internal();
            Internal.GetThread_0((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return LLDB.Thread.__CreateInstance(__ret);
        }

        public LLDB.Frame GetFrame()
        {
            var __ret = new LLDB.Frame.Internal();
            Internal.GetFrame_0((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return LLDB.Frame.__CreateInstance(__ret);
        }

        public LLDB.Value Dereference()
        {
            var __ret = new LLDB.Value.Internal();
            Internal.Dereference_0((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return LLDB.Value.__CreateInstance(__ret);
        }

        public bool TypeIsPointerType()
        {
            var __ret = Internal.TypeIsPointerType_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public LLDB.Type GetType()
        {
            var __ret = new LLDB.Type.Internal();
            Internal.GetType_0((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return LLDB.Type.__CreateInstance(__ret);
        }

        public LLDB.Value Persist()
        {
            var __ret = new LLDB.Value.Internal();
            Internal.Persist_0((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return LLDB.Value.__CreateInstance(__ret);
        }

        public bool GetDescription(LLDB.Stream description)
        {
            if (ReferenceEquals(description, null))
                throw new global::System.ArgumentNullException("description", "Cannot be null because it is a C++ reference (&).");
            var arg0 = description.__Instance;
            var __ret = Internal.GetDescription_0((__Instance + __PointerAdjustment), arg0);
            return __ret;
        }

        public bool GetExpressionPath(LLDB.Stream description)
        {
            if (ReferenceEquals(description, null))
                throw new global::System.ArgumentNullException("description", "Cannot be null because it is a C++ reference (&).");
            var arg0 = description.__Instance;
            var __ret = Internal.GetExpressionPath_0((__Instance + __PointerAdjustment), arg0);
            return __ret;
        }

        public bool GetExpressionPath(LLDB.Stream description, bool qualify_cxx_base_classes)
        {
            if (ReferenceEquals(description, null))
                throw new global::System.ArgumentNullException("description", "Cannot be null because it is a C++ reference (&).");
            var arg0 = description.__Instance;
            var __ret = Internal.GetExpressionPath_1((__Instance + __PointerAdjustment), arg0, qualify_cxx_base_classes);
            return __ret;
        }

        /// <summary>
        /// <para>Watch this value if it resides in memory.</para>
        /// </summary>
        /// <remarks>
        /// <para>Sets a watchpoint on the value.</para>
        /// </remarks>
        /// <param name="resolve_location">
        /// <para>Resolve the location of this value once and watch its address.</para>
        /// <para>This value must currently be set to</para>
        /// <para>as watching all</para>
        /// <para>locations of a variable or a variable path is not yet supported,</para>
        /// <para>though we plan to support it in the future.</para>
        /// </param>
        /// <param name="read">
        /// <para>Stop when this value is accessed.</para>
        /// </param>
        /// <param name="write">
        /// <para>Stop when this value is modified</para>
        /// </param>
        /// <param name="error">
        /// <para>An error object. Contains the reason if there is some failure.</para>
        /// </param>
        /// <returns>
        /// <para>An SBWatchpoint object. This object might not be valid upon</para>
        /// <para>return due to a value not being contained in memory, too</para>
        /// <para>large, or watchpoint resources are not available or all in</para>
        /// <para>use.</para>
        /// </returns>
        public LLDB.Watchpoint Watch(bool resolve_location, bool read, bool write, out LLDB.Error error)
        {
            error = new LLDB.Error();
            if (ReferenceEquals(error, null))
                throw new global::System.ArgumentNullException("error", "Cannot be null because it is a C++ reference (&).");
            var arg3 = error.__Instance;
            var __ret = new LLDB.Watchpoint.Internal();
            Internal.Watch_0((__Instance + __PointerAdjustment), new IntPtr(&__ret), resolve_location, read, write, arg3);
            LLDB.Error __result0;
            if (arg3 == IntPtr.Zero) __result0 = null;
            else if (LLDB.Error.NativeToManagedMap.ContainsKey(arg3))
                __result0 = (LLDB.Error) LLDB.Error.NativeToManagedMap[arg3];
            else __result0 = LLDB.Error.__CreateInstance(arg3);
            error = __result0;
            return LLDB.Watchpoint.__CreateInstance(__ret);
        }

        public LLDB.Watchpoint Watch(bool resolve_location, bool read, bool write)
        {
            var __ret = new LLDB.Watchpoint.Internal();
            Internal.Watch_1((__Instance + __PointerAdjustment), new IntPtr(&__ret), resolve_location, read, write);
            return LLDB.Watchpoint.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Watch this value that this value points to in memory</para>
        /// </summary>
        /// <remarks>
        /// <para>Sets a watchpoint on the value.</para>
        /// </remarks>
        /// <param name="resolve_location">
        /// <para>Resolve the location of this value once and watch its address.</para>
        /// <para>This value must currently be set to</para>
        /// <para>as watching all</para>
        /// <para>locations of a variable or a variable path is not yet supported,</para>
        /// <para>though we plan to support it in the future.</para>
        /// </param>
        /// <param name="read">
        /// <para>Stop when this value is accessed.</para>
        /// </param>
        /// <param name="write">
        /// <para>Stop when this value is modified</para>
        /// </param>
        /// <param name="error">
        /// <para>An error object. Contains the reason if there is some failure.</para>
        /// </param>
        /// <returns>
        /// <para>An SBWatchpoint object. This object might not be valid upon</para>
        /// <para>return due to a value not being contained in memory, too</para>
        /// <para>large, or watchpoint resources are not available or all in</para>
        /// <para>use.</para>
        /// </returns>
        public LLDB.Watchpoint WatchPointee(bool resolve_location, bool read, bool write, out LLDB.Error error)
        {
            error = new LLDB.Error();
            if (ReferenceEquals(error, null))
                throw new global::System.ArgumentNullException("error", "Cannot be null because it is a C++ reference (&).");
            var arg3 = error.__Instance;
            var __ret = new LLDB.Watchpoint.Internal();
            Internal.WatchPointee_0((__Instance + __PointerAdjustment), new IntPtr(&__ret), resolve_location, read, write, arg3);
            LLDB.Error __result0;
            if (arg3 == IntPtr.Zero) __result0 = null;
            else if (LLDB.Error.NativeToManagedMap.ContainsKey(arg3))
                __result0 = (LLDB.Error) LLDB.Error.NativeToManagedMap[arg3];
            else __result0 = LLDB.Error.__CreateInstance(arg3);
            error = __result0;
            return LLDB.Watchpoint.__CreateInstance(__ret);
        }

        public ulong ID
        {
            get
            {
                var __ret = Internal.GetID_0((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public string Name
        {
            get
            {
                var __ret = Internal.GetName_0((__Instance + __PointerAdjustment));
                return Marshal.PtrToStringAnsi(__ret);
            }
        }

        public string TypeName
        {
            get
            {
                var __ret = Internal.GetTypeName_0((__Instance + __PointerAdjustment));
                return Marshal.PtrToStringAnsi(__ret);
            }
        }

        public string DisplayTypeName
        {
            get
            {
                var __ret = Internal.GetDisplayTypeName_0((__Instance + __PointerAdjustment));
                return Marshal.PtrToStringAnsi(__ret);
            }
        }

        public uint ByteSize
        {
            get
            {
                var __ret = Internal.GetByteSize_0((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public LLDB.Format Format
        {
            get
            {
                var __ret = Internal.GetFormat_0((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var arg0 = value;
                Internal.SetFormat_0((__Instance + __PointerAdjustment), arg0);
            }
        }

        public string ValueAsString
        {
            get
            {
                var __ret = Internal.GetValueAsString_0((__Instance + __PointerAdjustment));
                return Marshal.PtrToStringAnsi(__ret);
            }
        }

        public LLDB.ValueType ValueType
        {
            get
            {
                var __ret = Internal.GetValueType_0((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public bool ValueDidChange
        {
            get
            {
                var __ret = Internal.GetValueDidChange_0((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public string Summary
        {
            get
            {
                var __ret = Internal.GetSummary_0((__Instance + __PointerAdjustment));
                return Marshal.PtrToStringAnsi(__ret);
            }
        }

        public string ObjectDescription
        {
            get
            {
                var __ret = Internal.GetObjectDescription_0((__Instance + __PointerAdjustment));
                return Marshal.PtrToStringAnsi(__ret);
            }
        }

        public string TypeValidatorResult
        {
            get
            {
                var __ret = Internal.GetTypeValidatorResult_0((__Instance + __PointerAdjustment));
                return Marshal.PtrToStringAnsi(__ret);
            }
        }

        public LLDB.DynamicValueType PreferDynamicValue
        {
            get
            {
                var __ret = Internal.GetPreferDynamicValue_0((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var arg0 = value;
                Internal.SetPreferDynamicValue_0((__Instance + __PointerAdjustment), arg0);
            }
        }

        public bool PreferSyntheticValue
        {
            get
            {
                var __ret = Internal.GetPreferSyntheticValue_0((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                Internal.SetPreferSyntheticValue_0((__Instance + __PointerAdjustment), value);
            }
        }

        public string Location
        {
            get
            {
                var __ret = Internal.GetLocation_0((__Instance + __PointerAdjustment));
                return Marshal.PtrToStringAnsi(__ret);
            }
        }

        public ulong LoadAddress
        {
            get
            {
                var __ret = Internal.GetLoadAddress_0((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public uint NumChildren
        {
            get
            {
                var __ret = Internal.GetNumChildren_0((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public global::System.IntPtr OpaqueType
        {
            get
            {
                var __ret = Internal.GetOpaqueType_0((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}
