//----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace LLDB
{
    public unsafe partial class Process : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0SBProcess@lldb@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0SBProcess@lldb@@QAE@ABV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr rhs);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??1SBProcess@lldb@@QAE@XZ")]
            internal static extern void dtor_0(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?Clear@SBProcess@lldb@@QAEXXZ")]
            internal static extern void Clear_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?IsValid@SBProcess@lldb@@QBE_NXZ")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsValid_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetTarget@SBProcess@lldb@@QBE?AVSBTarget@2@XZ")]
            internal static extern void GetTarget_0(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?PutSTDIN@SBProcess@lldb@@QAEIPBDI@Z")]
            internal static extern uint PutSTDIN_0(global::System.IntPtr instance, global::System.IntPtr src, uint src_len);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetSTDOUT@SBProcess@lldb@@QBEIPADI@Z")]
            internal static extern uint GetSTDOUT_0(global::System.IntPtr instance, sbyte* dst, uint dst_len);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetSTDERR@SBProcess@lldb@@QBEIPADI@Z")]
            internal static extern uint GetSTDERR_0(global::System.IntPtr instance, sbyte* dst, uint dst_len);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetAsyncProfileData@SBProcess@lldb@@QBEIPADI@Z")]
            internal static extern uint GetAsyncProfileData_0(global::System.IntPtr instance, sbyte* dst, uint dst_len);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?ReportEventState@SBProcess@lldb@@QBEXABVSBEvent@2@PAU_iobuf@@@Z")]
            internal static extern void ReportEventState_0(global::System.IntPtr instance, global::System.IntPtr @event, global::System.IntPtr @out);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?AppendEventStateReport@SBProcess@lldb@@QAEXABVSBEvent@2@AAVSBCommandReturnObject@2@@Z")]
            internal static extern void AppendEventStateReport_0(global::System.IntPtr instance, global::System.IntPtr @event, global::System.IntPtr result);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?RemoteAttachToProcessWithID@SBProcess@lldb@@QAE_N_KAAVSBError@2@@Z")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool RemoteAttachToProcessWithID_0(global::System.IntPtr instance, ulong pid, global::System.IntPtr error);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?RemoteLaunch@SBProcess@lldb@@QAE_NPAPBD0PBD111I_NAAVSBError@2@@Z")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool RemoteLaunch_0(global::System.IntPtr instance, sbyte** argv, sbyte** envp, global::System.IntPtr stdin_path, global::System.IntPtr stdout_path, global::System.IntPtr stderr_path, global::System.IntPtr working_directory, uint launch_flags, bool stop_at_entry, global::System.IntPtr error);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetThreadAtIndex@SBProcess@lldb@@QAE?AVSBThread@2@I@Z")]
            internal static extern void GetThreadAtIndex_0(global::System.IntPtr instance, global::System.IntPtr @return, uint index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetThreadByID@SBProcess@lldb@@QAE?AVSBThread@2@_K@Z")]
            internal static extern void GetThreadByID_0(global::System.IntPtr instance, global::System.IntPtr @return, ulong sb_thread_id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetThreadByIndexID@SBProcess@lldb@@QAE?AVSBThread@2@I@Z")]
            internal static extern void GetThreadByIndexID_0(global::System.IntPtr instance, global::System.IntPtr @return, uint index_id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetSelectedThread@SBProcess@lldb@@QBE?AVSBThread@2@XZ")]
            internal static extern void GetSelectedThread_0(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?CreateOSPluginThread@SBProcess@lldb@@QAE?AVSBThread@2@_K0@Z")]
            internal static extern void CreateOSPluginThread_0(global::System.IntPtr instance, global::System.IntPtr @return, ulong tid, ulong context);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?SetSelectedThread@SBProcess@lldb@@QAE_NABVSBThread@2@@Z")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool SetSelectedThread_0(global::System.IntPtr instance, global::System.IntPtr thread);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?SetSelectedThreadByID@SBProcess@lldb@@QAE_N_K@Z")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool SetSelectedThreadByID_0(global::System.IntPtr instance, ulong tid);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?SetSelectedThreadByIndexID@SBProcess@lldb@@QAE_NI@Z")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool SetSelectedThreadByIndexID_0(global::System.IntPtr instance, uint index_id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetQueueAtIndex@SBProcess@lldb@@QAE?AVSBQueue@2@I@Z")]
            internal static extern void GetQueueAtIndex_0(global::System.IntPtr instance, global::System.IntPtr @return, uint index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?Destroy@SBProcess@lldb@@QAE?AVSBError@2@XZ")]
            internal static extern void Destroy_0(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?Continue@SBProcess@lldb@@QAE?AVSBError@2@XZ")]
            internal static extern void Continue_0(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?Stop@SBProcess@lldb@@QAE?AVSBError@2@XZ")]
            internal static extern void Stop_0(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?Kill@SBProcess@lldb@@QAE?AVSBError@2@XZ")]
            internal static extern void Kill_0(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?Detach@SBProcess@lldb@@QAE?AVSBError@2@XZ")]
            internal static extern void Detach_0(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?Detach@SBProcess@lldb@@QAE?AVSBError@2@_N@Z")]
            internal static extern void Detach_1(global::System.IntPtr instance, global::System.IntPtr @return, bool keep_stopped);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?Signal@SBProcess@lldb@@QAE?AVSBError@2@H@Z")]
            internal static extern void Signal_0(global::System.IntPtr instance, global::System.IntPtr @return, int signal);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetUnixSignals@SBProcess@lldb@@QAE?AVSBUnixSignals@2@XZ")]
            internal static extern void GetUnixSignals_0(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?SendAsyncInterrupt@SBProcess@lldb@@QAEXXZ")]
            internal static extern void SendAsyncInterrupt_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetStopID@SBProcess@lldb@@QAEI_N@Z")]
            internal static extern uint GetStopID_0(global::System.IntPtr instance, bool include_expression_stops);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetStopEventForStopID@SBProcess@lldb@@QAE?AVSBEvent@2@I@Z")]
            internal static extern void GetStopEventForStopID_0(global::System.IntPtr instance, global::System.IntPtr @return, uint stop_id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?ReadMemory@SBProcess@lldb@@QAEI_KPAXIAAVSBError@2@@Z")]
            internal static extern uint ReadMemory_0(global::System.IntPtr instance, ulong addr, global::System.IntPtr buf, uint size, global::System.IntPtr error);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?WriteMemory@SBProcess@lldb@@QAEI_KPBXIAAVSBError@2@@Z")]
            internal static extern uint WriteMemory_0(global::System.IntPtr instance, ulong addr, global::System.IntPtr buf, uint size, global::System.IntPtr error);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?ReadCStringFromMemory@SBProcess@lldb@@QAEI_KPAXIAAVSBError@2@@Z")]
            internal static extern uint ReadCStringFromMemory_0(global::System.IntPtr instance, ulong addr, global::System.IntPtr buf, uint size, global::System.IntPtr error);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?ReadUnsignedFromMemory@SBProcess@lldb@@QAE_K_KIAAVSBError@2@@Z")]
            internal static extern ulong ReadUnsignedFromMemory_0(global::System.IntPtr instance, ulong addr, uint byte_size, global::System.IntPtr error);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?ReadPointerFromMemory@SBProcess@lldb@@QAE_K_KAAVSBError@2@@Z")]
            internal static extern ulong ReadPointerFromMemory_0(global::System.IntPtr instance, ulong addr, global::System.IntPtr error);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetStateFromEvent@SBProcess@lldb@@SA?AW4StateType@2@ABVSBEvent@2@@Z")]
            internal static extern LLDB.StateType GetStateFromEvent_0(global::System.IntPtr @event);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetRestartedFromEvent@SBProcess@lldb@@SA_NABVSBEvent@2@@Z")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool GetRestartedFromEvent_0(global::System.IntPtr @event);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetNumRestartedReasonsFromEvent@SBProcess@lldb@@SAIABVSBEvent@2@@Z")]
            internal static extern uint GetNumRestartedReasonsFromEvent_0(global::System.IntPtr @event);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetRestartedReasonAtIndexFromEvent@SBProcess@lldb@@SAPBDABVSBEvent@2@I@Z")]
            internal static extern global::System.IntPtr GetRestartedReasonAtIndexFromEvent_0(global::System.IntPtr @event, uint idx);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetProcessFromEvent@SBProcess@lldb@@SA?AV12@ABVSBEvent@2@@Z")]
            internal static extern void GetProcessFromEvent_0(global::System.IntPtr @return, global::System.IntPtr @event);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetInterruptedFromEvent@SBProcess@lldb@@SA_NABVSBEvent@2@@Z")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool GetInterruptedFromEvent_0(global::System.IntPtr @event);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?EventIsProcessEvent@SBProcess@lldb@@SA_NABVSBEvent@2@@Z")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool EventIsProcessEvent_0(global::System.IntPtr @event);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetBroadcaster@SBProcess@lldb@@QBE?AVSBBroadcaster@2@XZ")]
            internal static extern void GetBroadcaster_0(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetDescription@SBProcess@lldb@@QAE_NAAVSBStream@2@@Z")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool GetDescription_0(global::System.IntPtr instance, global::System.IntPtr description);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetNumSupportedHardwareWatchpoints@SBProcess@lldb@@QBEIAAVSBError@2@@Z")]
            internal static extern uint GetNumSupportedHardwareWatchpoints_0(global::System.IntPtr instance, global::System.IntPtr error);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?LoadImage@SBProcess@lldb@@QAEIAAVSBFileSpec@2@AAVSBError@2@@Z")]
            internal static extern uint LoadImage_0(global::System.IntPtr instance, global::System.IntPtr remote_image_spec, global::System.IntPtr error);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?LoadImage@SBProcess@lldb@@QAEIABVSBFileSpec@2@0AAVSBError@2@@Z")]
            internal static extern uint LoadImage_1(global::System.IntPtr instance, global::System.IntPtr local_image_spec, global::System.IntPtr remote_image_spec, global::System.IntPtr error);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?UnloadImage@SBProcess@lldb@@QAE?AVSBError@2@I@Z")]
            internal static extern void UnloadImage_0(global::System.IntPtr instance, global::System.IntPtr @return, uint image_token);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?SendEventData@SBProcess@lldb@@QAE?AVSBError@2@PBD@Z")]
            internal static extern void SendEventData_0(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetExtendedBacktraceTypeAtIndex@SBProcess@lldb@@QAEPBDI@Z")]
            internal static extern global::System.IntPtr GetExtendedBacktraceTypeAtIndex_0(global::System.IntPtr instance, uint idx);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetHistoryThreads@SBProcess@lldb@@QAE?AVSBThreadCollection@2@_K@Z")]
            internal static extern void GetHistoryThreads_0(global::System.IntPtr instance, global::System.IntPtr @return, ulong addr);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?IsInstrumentationRuntimePresent@SBProcess@lldb@@QAE_NW4InstrumentationRuntimeType@2@@Z")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsInstrumentationRuntimePresent_0(global::System.IntPtr instance, LLDB.InstrumentationRuntimeType type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?SaveCore@SBProcess@lldb@@QAE?AVSBError@2@PBD@Z")]
            internal static extern void SaveCore_0(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr file_name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetBroadcasterClassName@SBProcess@lldb@@SAPBDXZ")]
            internal static extern global::System.IntPtr GetBroadcasterClassName_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetPluginName@SBProcess@lldb@@QAEPBDXZ")]
            internal static extern global::System.IntPtr GetPluginName_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetShortPluginName@SBProcess@lldb@@QAEPBDXZ")]
            internal static extern global::System.IntPtr GetShortPluginName_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetByteOrder@SBProcess@lldb@@QBE?AW4ByteOrder@2@XZ")]
            internal static extern LLDB.ByteOrder GetByteOrder_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetNumThreads@SBProcess@lldb@@QAEIXZ")]
            internal static extern uint GetNumThreads_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetNumQueues@SBProcess@lldb@@QAEIXZ")]
            internal static extern uint GetNumQueues_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetState@SBProcess@lldb@@QAE?AW4StateType@2@XZ")]
            internal static extern LLDB.StateType GetState_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetExitStatus@SBProcess@lldb@@QAEHXZ")]
            internal static extern int GetExitStatus_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetExitDescription@SBProcess@lldb@@QAEPBDXZ")]
            internal static extern global::System.IntPtr GetExitDescription_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetProcessID@SBProcess@lldb@@QAE_KXZ")]
            internal static extern ulong GetProcessID_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetUniqueID@SBProcess@lldb@@QAEIXZ")]
            internal static extern uint GetUniqueID_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetAddressByteSize@SBProcess@lldb@@QBEIXZ")]
            internal static extern uint GetAddressByteSize_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetBroadcasterClass@SBProcess@lldb@@SAPBDXZ")]
            internal static extern global::System.IntPtr GetBroadcasterClass_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetNumExtendedBacktraceTypes@SBProcess@lldb@@QAEIXZ")]
            internal static extern uint GetNumExtendedBacktraceTypes_0(global::System.IntPtr instance);
        }

        [Flags]
        public enum BroadcastBit : uint
        {
            BroadcastBitStateChanged = 1,
            BroadcastBitInterrupt = 2,
            BroadcastBitSTDOUT = 4,
            BroadcastBitSTDERR = 8,
            BroadcastBitProfileData = 16
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Process> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Process>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        public static Process __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new Process(native.ToPointer(), skipVTables);
        }

        public static Process __CreateInstance(Process.Internal native, bool skipVTables = false)
        {
            return new Process(native, skipVTables);
        }

        private static void* __CopyValue(Process.Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            LLDB.Process.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Process(Process.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Process(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Process()
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            Internal.ctor_0((__Instance + __PointerAdjustment));
        }

        public Process(LLDB.Process rhs)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(rhs, null))
                throw new global::System.ArgumentNullException("rhs", "Cannot be null because it is a C++ reference (&).");
            var arg0 = rhs.__Instance;
            Internal.cctor_1((__Instance + __PointerAdjustment), arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        protected virtual void Dispose(bool disposing)
        {
            LLDB.Process __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            Internal.dtor_0((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public void Clear()
        {
            Internal.Clear_0((__Instance + __PointerAdjustment));
        }

        public bool IsValid()
        {
            var __ret = Internal.IsValid_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public LLDB.Target GetTarget()
        {
            var __ret = new LLDB.Target.Internal();
            Internal.GetTarget_0((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return LLDB.Target.__CreateInstance(__ret);
        }

        public uint PutSTDIN(string src, uint src_len)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(src);
            var __ret = Internal.PutSTDIN_0((__Instance + __PointerAdjustment), arg0, src_len);
            Marshal.FreeHGlobal(arg0);
            return __ret;
        }

        public uint GetSTDOUT(sbyte* dst, uint dst_len)
        {
            var arg0 = dst;
            var __ret = Internal.GetSTDOUT_0((__Instance + __PointerAdjustment), arg0, dst_len);
            return __ret;
        }

        public uint GetSTDERR(sbyte* dst, uint dst_len)
        {
            var arg0 = dst;
            var __ret = Internal.GetSTDERR_0((__Instance + __PointerAdjustment), arg0, dst_len);
            return __ret;
        }

        public uint GetAsyncProfileData(sbyte* dst, uint dst_len)
        {
            var arg0 = dst;
            var __ret = Internal.GetAsyncProfileData_0((__Instance + __PointerAdjustment), arg0, dst_len);
            return __ret;
        }

        public void ReportEventState(LLDB.Event @event, global::System.IntPtr @out)
        {
            if (ReferenceEquals(@event, null))
                throw new global::System.ArgumentNullException("@event", "Cannot be null because it is a C++ reference (&).");
            var arg0 = @event.__Instance;
            var arg1 = @out;
            Internal.ReportEventState_0((__Instance + __PointerAdjustment), arg0, arg1);
        }

        public void AppendEventStateReport(LLDB.Event @event, LLDB.CommandReturnObject result)
        {
            if (ReferenceEquals(@event, null))
                throw new global::System.ArgumentNullException("@event", "Cannot be null because it is a C++ reference (&).");
            var arg0 = @event.__Instance;
            if (ReferenceEquals(result, null))
                throw new global::System.ArgumentNullException("result", "Cannot be null because it is a C++ reference (&).");
            var arg1 = result.__Instance;
            Internal.AppendEventStateReport_0((__Instance + __PointerAdjustment), arg0, arg1);
        }

        /// <summary>
        /// <para>Remote connection related functions. These will fail if the</para>
        /// <para>process is not in eStateConnected. They are intended for use</para>
        /// <para>when connecting to an externally managed debugserver instance.</para>
        /// </summary>
        public bool RemoteAttachToProcessWithID(ulong pid, LLDB.Error error)
        {
            if (ReferenceEquals(error, null))
                throw new global::System.ArgumentNullException("error", "Cannot be null because it is a C++ reference (&).");
            var arg1 = error.__Instance;
            var __ret = Internal.RemoteAttachToProcessWithID_0((__Instance + __PointerAdjustment), pid, arg1);
            return __ret;
        }

        public bool RemoteLaunch(sbyte** argv, sbyte** envp, string stdin_path, string stdout_path, string stderr_path, string working_directory, uint launch_flags, bool stop_at_entry, LLDB.Error error)
        {
            var arg0 = argv;
            var arg1 = envp;
            var arg2 = Marshal.StringToHGlobalAnsi(stdin_path);
            var arg3 = Marshal.StringToHGlobalAnsi(stdout_path);
            var arg4 = Marshal.StringToHGlobalAnsi(stderr_path);
            var arg5 = Marshal.StringToHGlobalAnsi(working_directory);
            if (ReferenceEquals(error, null))
                throw new global::System.ArgumentNullException("error", "Cannot be null because it is a C++ reference (&).");
            var arg8 = error.__Instance;
            var __ret = Internal.RemoteLaunch_0((__Instance + __PointerAdjustment), arg0, arg1, arg2, arg3, arg4, arg5, launch_flags, stop_at_entry, arg8);
            Marshal.FreeHGlobal(arg2);
            Marshal.FreeHGlobal(arg3);
            Marshal.FreeHGlobal(arg4);
            Marshal.FreeHGlobal(arg5);
            return __ret;
        }

        public LLDB.Thread GetThreadAtIndex(uint index)
        {
            var __ret = new LLDB.Thread.Internal();
            Internal.GetThreadAtIndex_0((__Instance + __PointerAdjustment), new IntPtr(&__ret), index);
            return LLDB.Thread.__CreateInstance(__ret);
        }

        public LLDB.Thread GetThreadByID(ulong sb_thread_id)
        {
            var __ret = new LLDB.Thread.Internal();
            Internal.GetThreadByID_0((__Instance + __PointerAdjustment), new IntPtr(&__ret), sb_thread_id);
            return LLDB.Thread.__CreateInstance(__ret);
        }

        public LLDB.Thread GetThreadByIndexID(uint index_id)
        {
            var __ret = new LLDB.Thread.Internal();
            Internal.GetThreadByIndexID_0((__Instance + __PointerAdjustment), new IntPtr(&__ret), index_id);
            return LLDB.Thread.__CreateInstance(__ret);
        }

        public LLDB.Thread GetSelectedThread()
        {
            var __ret = new LLDB.Thread.Internal();
            Internal.GetSelectedThread_0((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return LLDB.Thread.__CreateInstance(__ret);
        }

        public LLDB.Thread CreateOSPluginThread(ulong tid, ulong context)
        {
            var __ret = new LLDB.Thread.Internal();
            Internal.CreateOSPluginThread_0((__Instance + __PointerAdjustment), new IntPtr(&__ret), tid, context);
            return LLDB.Thread.__CreateInstance(__ret);
        }

        public bool SetSelectedThread(LLDB.Thread thread)
        {
            if (ReferenceEquals(thread, null))
                throw new global::System.ArgumentNullException("thread", "Cannot be null because it is a C++ reference (&).");
            var arg0 = thread.__Instance;
            var __ret = Internal.SetSelectedThread_0((__Instance + __PointerAdjustment), arg0);
            return __ret;
        }

        public bool SetSelectedThreadByID(ulong tid)
        {
            var __ret = Internal.SetSelectedThreadByID_0((__Instance + __PointerAdjustment), tid);
            return __ret;
        }

        public bool SetSelectedThreadByIndexID(uint index_id)
        {
            var __ret = Internal.SetSelectedThreadByIndexID_0((__Instance + __PointerAdjustment), index_id);
            return __ret;
        }

        public LLDB.Queue GetQueueAtIndex(uint index)
        {
            var __ret = new LLDB.Queue.Internal();
            Internal.GetQueueAtIndex_0((__Instance + __PointerAdjustment), new IntPtr(&__ret), index);
            return LLDB.Queue.__CreateInstance(__ret);
        }

        public LLDB.Error Destroy()
        {
            var __ret = new LLDB.Error.Internal();
            Internal.Destroy_0((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return LLDB.Error.__CreateInstance(__ret);
        }

        public LLDB.Error Continue()
        {
            var __ret = new LLDB.Error.Internal();
            Internal.Continue_0((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return LLDB.Error.__CreateInstance(__ret);
        }

        public LLDB.Error Stop()
        {
            var __ret = new LLDB.Error.Internal();
            Internal.Stop_0((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return LLDB.Error.__CreateInstance(__ret);
        }

        public LLDB.Error Kill()
        {
            var __ret = new LLDB.Error.Internal();
            Internal.Kill_0((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return LLDB.Error.__CreateInstance(__ret);
        }

        public LLDB.Error Detach()
        {
            var __ret = new LLDB.Error.Internal();
            Internal.Detach_0((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return LLDB.Error.__CreateInstance(__ret);
        }

        public LLDB.Error Detach(bool keep_stopped)
        {
            var __ret = new LLDB.Error.Internal();
            Internal.Detach_1((__Instance + __PointerAdjustment), new IntPtr(&__ret), keep_stopped);
            return LLDB.Error.__CreateInstance(__ret);
        }

        public LLDB.Error Signal(int signal)
        {
            var __ret = new LLDB.Error.Internal();
            Internal.Signal_0((__Instance + __PointerAdjustment), new IntPtr(&__ret), signal);
            return LLDB.Error.__CreateInstance(__ret);
        }

        public LLDB.UnixSignals GetUnixSignals()
        {
            var __ret = new LLDB.UnixSignals.Internal();
            Internal.GetUnixSignals_0((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return LLDB.UnixSignals.__CreateInstance(__ret);
        }

        public void SendAsyncInterrupt()
        {
            Internal.SendAsyncInterrupt_0((__Instance + __PointerAdjustment));
        }

        public uint GetStopID(bool include_expression_stops)
        {
            var __ret = Internal.GetStopID_0((__Instance + __PointerAdjustment), include_expression_stops);
            return __ret;
        }

        /// <summary>
        /// <para>Note that it wasn't fully implemented and tracks only the stop</para>
        /// <para>event for the last natural stop ID.</para>
        /// </summary>
        /// <param name="stop_id">
        /// <para>The ID of the stop event to return.</para>
        /// </param>
        /// <returns>
        /// <para>The stop event corresponding to stop ID.</para>
        /// </returns>
        public LLDB.Event GetStopEventForStopID(uint stop_id)
        {
            var __ret = new LLDB.Event.Internal();
            Internal.GetStopEventForStopID_0((__Instance + __PointerAdjustment), new IntPtr(&__ret), stop_id);
            return LLDB.Event.__CreateInstance(__ret);
        }

        public uint ReadMemory(ulong addr, global::System.IntPtr buf, uint size, LLDB.Error error)
        {
            var arg1 = buf;
            if (ReferenceEquals(error, null))
                throw new global::System.ArgumentNullException("error", "Cannot be null because it is a C++ reference (&).");
            var arg3 = error.__Instance;
            var __ret = Internal.ReadMemory_0((__Instance + __PointerAdjustment), addr, arg1, size, arg3);
            return __ret;
        }

        public uint WriteMemory(ulong addr, global::System.IntPtr buf, uint size, LLDB.Error error)
        {
            var arg1 = buf;
            if (ReferenceEquals(error, null))
                throw new global::System.ArgumentNullException("error", "Cannot be null because it is a C++ reference (&).");
            var arg3 = error.__Instance;
            var __ret = Internal.WriteMemory_0((__Instance + __PointerAdjustment), addr, arg1, size, arg3);
            return __ret;
        }

        public uint ReadCStringFromMemory(ulong addr, global::System.IntPtr buf, uint size, LLDB.Error error)
        {
            var arg1 = buf;
            if (ReferenceEquals(error, null))
                throw new global::System.ArgumentNullException("error", "Cannot be null because it is a C++ reference (&).");
            var arg3 = error.__Instance;
            var __ret = Internal.ReadCStringFromMemory_0((__Instance + __PointerAdjustment), addr, arg1, size, arg3);
            return __ret;
        }

        public ulong ReadUnsignedFromMemory(ulong addr, uint byte_size, LLDB.Error error)
        {
            if (ReferenceEquals(error, null))
                throw new global::System.ArgumentNullException("error", "Cannot be null because it is a C++ reference (&).");
            var arg2 = error.__Instance;
            var __ret = Internal.ReadUnsignedFromMemory_0((__Instance + __PointerAdjustment), addr, byte_size, arg2);
            return __ret;
        }

        public ulong ReadPointerFromMemory(ulong addr, LLDB.Error error)
        {
            if (ReferenceEquals(error, null))
                throw new global::System.ArgumentNullException("error", "Cannot be null because it is a C++ reference (&).");
            var arg1 = error.__Instance;
            var __ret = Internal.ReadPointerFromMemory_0((__Instance + __PointerAdjustment), addr, arg1);
            return __ret;
        }

        public LLDB.Broadcaster GetBroadcaster()
        {
            var __ret = new LLDB.Broadcaster.Internal();
            Internal.GetBroadcaster_0((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return LLDB.Broadcaster.__CreateInstance(__ret);
        }

        public bool GetDescription(LLDB.Stream description)
        {
            if (ReferenceEquals(description, null))
                throw new global::System.ArgumentNullException("description", "Cannot be null because it is a C++ reference (&).");
            var arg0 = description.__Instance;
            var __ret = Internal.GetDescription_0((__Instance + __PointerAdjustment), arg0);
            return __ret;
        }

        public uint GetNumSupportedHardwareWatchpoints(LLDB.Error error)
        {
            if (ReferenceEquals(error, null))
                throw new global::System.ArgumentNullException("error", "Cannot be null because it is a C++ reference (&).");
            var arg0 = error.__Instance;
            var __ret = Internal.GetNumSupportedHardwareWatchpoints_0((__Instance + __PointerAdjustment), arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Load a shared library into this process.</para>
        /// </summary>
        /// <param name="remote_image_spec">
        /// <para>The path for the shared library on the target what you want</para>
        /// <para>to load.</para>
        /// </param>
        /// <param name="error">
        /// <para>An error object that gets filled in with any errors that</para>
        /// <para>might occur when trying to load the shared library.</para>
        /// </param>
        /// <returns>
        /// <para>A token that represents the shared library that can be</para>
        /// <para>later used to unload the shared library. A value of</para>
        /// <para>LLDB_INVALID_IMAGE_TOKEN will be returned if the shared</para>
        /// <para>library can't be opened.</para>
        /// </returns>
        public uint LoadImage(LLDB.FileSpec remote_image_spec, out LLDB.Error error)
        {
            if (ReferenceEquals(remote_image_spec, null))
                throw new global::System.ArgumentNullException("remote_image_spec", "Cannot be null because it is a C++ reference (&).");
            var arg0 = remote_image_spec.__Instance;
            error = new LLDB.Error();
            if (ReferenceEquals(error, null))
                throw new global::System.ArgumentNullException("error", "Cannot be null because it is a C++ reference (&).");
            var arg1 = error.__Instance;
            var __ret = Internal.LoadImage_0((__Instance + __PointerAdjustment), arg0, arg1);
            LLDB.Error __result0;
            if (arg1 == IntPtr.Zero) __result0 = null;
            else if (LLDB.Error.NativeToManagedMap.ContainsKey(arg1))
                __result0 = (LLDB.Error) LLDB.Error.NativeToManagedMap[arg1];
            else __result0 = LLDB.Error.__CreateInstance(arg1);
            error = __result0;
            return __ret;
        }

        /// <summary>
        /// <para>Load a shared library into this process.</para>
        /// </summary>
        /// <param name="local_image_spec">
        /// <para>The file spec that points to the shared library that you</para>
        /// <para>want to load if the library is located on the host. The</para>
        /// <para>library will be copied over to the location specified by</para>
        /// <para>remote_image_spec or into the current working directory with</para>
        /// <para>the same filename if the remote_image_spec isn't specified.</para>
        /// </param>
        /// <param name="remote_image_spec">
        /// <para>If local_image_spec is specified then the location where the</para>
        /// <para>library should be copied over from the host. If</para>
        /// <para>local_image_spec isn't specified, then the path for the</para>
        /// <para>shared library on the target what you want to load.</para>
        /// </param>
        /// <param name="error">
        /// <para>An error object that gets filled in with any errors that</para>
        /// <para>might occur when trying to load the shared library.</para>
        /// </param>
        /// <returns>
        /// <para>A token that represents the shared library that can be</para>
        /// <para>later used to unload the shared library. A value of</para>
        /// <para>LLDB_INVALID_IMAGE_TOKEN will be returned if the shared</para>
        /// <para>library can't be opened.</para>
        /// </returns>
        public uint LoadImage(LLDB.FileSpec local_image_spec, LLDB.FileSpec remote_image_spec, out LLDB.Error error)
        {
            if (ReferenceEquals(local_image_spec, null))
                throw new global::System.ArgumentNullException("local_image_spec", "Cannot be null because it is a C++ reference (&).");
            var arg0 = local_image_spec.__Instance;
            if (ReferenceEquals(remote_image_spec, null))
                throw new global::System.ArgumentNullException("remote_image_spec", "Cannot be null because it is a C++ reference (&).");
            var arg1 = remote_image_spec.__Instance;
            error = new LLDB.Error();
            if (ReferenceEquals(error, null))
                throw new global::System.ArgumentNullException("error", "Cannot be null because it is a C++ reference (&).");
            var arg2 = error.__Instance;
            var __ret = Internal.LoadImage_1((__Instance + __PointerAdjustment), arg0, arg1, arg2);
            LLDB.Error __result0;
            if (arg2 == IntPtr.Zero) __result0 = null;
            else if (LLDB.Error.NativeToManagedMap.ContainsKey(arg2))
                __result0 = (LLDB.Error) LLDB.Error.NativeToManagedMap[arg2];
            else __result0 = LLDB.Error.__CreateInstance(arg2);
            error = __result0;
            return __ret;
        }

        public LLDB.Error UnloadImage(uint image_token)
        {
            var __ret = new LLDB.Error.Internal();
            Internal.UnloadImage_0((__Instance + __PointerAdjustment), new IntPtr(&__ret), image_token);
            return LLDB.Error.__CreateInstance(__ret);
        }

        public LLDB.Error SendEventData(string data)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(data);
            var __ret = new LLDB.Error.Internal();
            Internal.SendEventData_0((__Instance + __PointerAdjustment), new IntPtr(&__ret), arg0);
            Marshal.FreeHGlobal(arg0);
            return LLDB.Error.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Return the name of one of the thread-origin extended backtrace </para>
        /// <para>methods.</para>
        /// </summary>
        /// <param name="idx">
        /// <para>The index of the name to return.  They will be returned in</para>
        /// <para>the order that the user will most likely want to see them.</para>
        /// <para>e.g. if the type at index 0 is not available for a thread,</para>
        /// <para>see if the type at index 1 provides an extended backtrace.</para>
        /// </param>
        /// <returns>
        /// <para>The name at that index.</para>
        /// </returns>
        public string GetExtendedBacktraceTypeAtIndex(uint idx)
        {
            var __ret = Internal.GetExtendedBacktraceTypeAtIndex_0((__Instance + __PointerAdjustment), idx);
            return Marshal.PtrToStringAnsi(__ret);
        }

        public LLDB.ThreadCollection GetHistoryThreads(ulong addr)
        {
            var __ret = new LLDB.ThreadCollection.Internal();
            Internal.GetHistoryThreads_0((__Instance + __PointerAdjustment), new IntPtr(&__ret), addr);
            return LLDB.ThreadCollection.__CreateInstance(__ret);
        }

        public bool IsInstrumentationRuntimePresent(LLDB.InstrumentationRuntimeType type)
        {
            var arg0 = type;
            var __ret = Internal.IsInstrumentationRuntimePresent_0((__Instance + __PointerAdjustment), arg0);
            return __ret;
        }

        public LLDB.Error SaveCore(string file_name)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(file_name);
            var __ret = new LLDB.Error.Internal();
            Internal.SaveCore_0((__Instance + __PointerAdjustment), new IntPtr(&__ret), arg0);
            Marshal.FreeHGlobal(arg0);
            return LLDB.Error.__CreateInstance(__ret);
        }

        public static LLDB.StateType GetStateFromEvent(LLDB.Event @event)
        {
            if (ReferenceEquals(@event, null))
                throw new global::System.ArgumentNullException("@event", "Cannot be null because it is a C++ reference (&).");
            var arg0 = @event.__Instance;
            var __ret = Internal.GetStateFromEvent_0(arg0);
            return __ret;
        }

        public static bool GetRestartedFromEvent(LLDB.Event @event)
        {
            if (ReferenceEquals(@event, null))
                throw new global::System.ArgumentNullException("@event", "Cannot be null because it is a C++ reference (&).");
            var arg0 = @event.__Instance;
            var __ret = Internal.GetRestartedFromEvent_0(arg0);
            return __ret;
        }

        public static uint GetNumRestartedReasonsFromEvent(LLDB.Event @event)
        {
            if (ReferenceEquals(@event, null))
                throw new global::System.ArgumentNullException("@event", "Cannot be null because it is a C++ reference (&).");
            var arg0 = @event.__Instance;
            var __ret = Internal.GetNumRestartedReasonsFromEvent_0(arg0);
            return __ret;
        }

        public static string GetRestartedReasonAtIndexFromEvent(LLDB.Event @event, uint idx)
        {
            if (ReferenceEquals(@event, null))
                throw new global::System.ArgumentNullException("@event", "Cannot be null because it is a C++ reference (&).");
            var arg0 = @event.__Instance;
            var __ret = Internal.GetRestartedReasonAtIndexFromEvent_0(arg0, idx);
            return Marshal.PtrToStringAnsi(__ret);
        }

        public static LLDB.Process GetProcessFromEvent(LLDB.Event @event)
        {
            if (ReferenceEquals(@event, null))
                throw new global::System.ArgumentNullException("@event", "Cannot be null because it is a C++ reference (&).");
            var arg0 = @event.__Instance;
            var __ret = new LLDB.Process.Internal();
            Internal.GetProcessFromEvent_0(new IntPtr(&__ret), arg0);
            return LLDB.Process.__CreateInstance(__ret);
        }

        public static bool GetInterruptedFromEvent(LLDB.Event @event)
        {
            if (ReferenceEquals(@event, null))
                throw new global::System.ArgumentNullException("@event", "Cannot be null because it is a C++ reference (&).");
            var arg0 = @event.__Instance;
            var __ret = Internal.GetInterruptedFromEvent_0(arg0);
            return __ret;
        }

        public static bool EventIsProcessEvent(LLDB.Event @event)
        {
            if (ReferenceEquals(@event, null))
                throw new global::System.ArgumentNullException("@event", "Cannot be null because it is a C++ reference (&).");
            var arg0 = @event.__Instance;
            var __ret = Internal.EventIsProcessEvent_0(arg0);
            return __ret;
        }

        public static string BroadcasterClassName
        {
            get
            {
                var __ret = Internal.GetBroadcasterClassName_0();
                return Marshal.PtrToStringAnsi(__ret);
            }
        }

        public string PluginName
        {
            get
            {
                var __ret = Internal.GetPluginName_0((__Instance + __PointerAdjustment));
                return Marshal.PtrToStringAnsi(__ret);
            }
        }

        public string ShortPluginName
        {
            get
            {
                var __ret = Internal.GetShortPluginName_0((__Instance + __PointerAdjustment));
                return Marshal.PtrToStringAnsi(__ret);
            }
        }

        public LLDB.ByteOrder ByteOrder
        {
            get
            {
                var __ret = Internal.GetByteOrder_0((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public uint NumThreads
        {
            get
            {
                var __ret = Internal.GetNumThreads_0((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public uint NumQueues
        {
            get
            {
                var __ret = Internal.GetNumQueues_0((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public LLDB.StateType State
        {
            get
            {
                var __ret = Internal.GetState_0((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public int ExitStatus
        {
            get
            {
                var __ret = Internal.GetExitStatus_0((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public string ExitDescription
        {
            get
            {
                var __ret = Internal.GetExitDescription_0((__Instance + __PointerAdjustment));
                return Marshal.PtrToStringAnsi(__ret);
            }
        }

        public ulong ProcessID
        {
            get
            {
                var __ret = Internal.GetProcessID_0((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public uint UniqueID
        {
            get
            {
                var __ret = Internal.GetUniqueID_0((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public uint AddressByteSize
        {
            get
            {
                var __ret = Internal.GetAddressByteSize_0((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public static string BroadcasterClass
        {
            get
            {
                var __ret = Internal.GetBroadcasterClass_0();
                return Marshal.PtrToStringAnsi(__ret);
            }
        }

        public uint NumExtendedBacktraceTypes
        {
            get
            {
                var __ret = Internal.GetNumExtendedBacktraceTypes_0((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}
