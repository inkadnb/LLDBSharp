//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace LLDB
{
    public unsafe partial class Target : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0SBTarget@lldb@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0SBTarget@lldb@@QAE@ABV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr rhs);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??1SBTarget@lldb@@QAE@XZ")]
            internal static extern void dtor_0(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?IsValid@SBTarget@lldb@@QBE_NXZ")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsValid_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?EventIsTargetEvent@SBTarget@lldb@@SA_NABVSBEvent@2@@Z")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool EventIsTargetEvent_0(global::System.IntPtr @event);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTargetFromEvent@SBTarget@lldb@@SA?AV12@ABVSBEvent@2@@Z")]
            internal static extern void GetTargetFromEvent_0(global::System.IntPtr @return, global::System.IntPtr @event);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetNumModulesFromEvent@SBTarget@lldb@@SAIABVSBEvent@2@@Z")]
            internal static extern uint GetNumModulesFromEvent_0(global::System.IntPtr @event);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetModuleAtIndexFromEvent@SBTarget@lldb@@SA?AVSBModule@2@IABVSBEvent@2@@Z")]
            internal static extern void GetModuleAtIndexFromEvent_0(global::System.IntPtr @return, uint idx, global::System.IntPtr @event);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetProcess@SBTarget@lldb@@QAE?AVSBProcess@2@XZ")]
            internal static extern void GetProcess_0(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetPlatform@SBTarget@lldb@@QAE?AVSBPlatform@2@XZ")]
            internal static extern void GetPlatform_0(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?Install@SBTarget@lldb@@QAE?AVSBError@2@XZ")]
            internal static extern void Install_0(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?Launch@SBTarget@lldb@@QAE?AVSBProcess@2@AAVSBListener@2@PAPBD1PBD222I_NAAVSBError@2@@Z")]
            internal static extern void Launch_0(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr listener, sbyte** argv, sbyte** envp, global::System.IntPtr stdin_path, global::System.IntPtr stdout_path, global::System.IntPtr stderr_path, global::System.IntPtr working_directory, uint launch_flags, bool stop_at_entry, global::System.IntPtr error);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?LaunchSimple@SBTarget@lldb@@QAE?AVSBProcess@2@PAPBD0PBD@Z")]
            internal static extern void LaunchSimple_0(global::System.IntPtr instance, global::System.IntPtr @return, sbyte** argv, sbyte** envp, global::System.IntPtr working_directory);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?Launch@SBTarget@lldb@@QAE?AVSBProcess@2@AAVSBLaunchInfo@2@AAVSBError@2@@Z")]
            internal static extern void Launch_1(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr launch_info, global::System.IntPtr error);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?LoadCore@SBTarget@lldb@@QAE?AVSBProcess@2@PBD@Z")]
            internal static extern void LoadCore_0(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr core_file);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?Attach@SBTarget@lldb@@QAE?AVSBProcess@2@AAVSBAttachInfo@2@AAVSBError@2@@Z")]
            internal static extern void Attach_0(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr attach_info, global::System.IntPtr error);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?AttachToProcessWithID@SBTarget@lldb@@QAE?AVSBProcess@2@AAVSBListener@2@_KAAVSBError@2@@Z")]
            internal static extern void AttachToProcessWithID_0(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr listener, ulong pid, global::System.IntPtr error);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?AttachToProcessWithName@SBTarget@lldb@@QAE?AVSBProcess@2@AAVSBListener@2@PBD_NAAVSBError@2@@Z")]
            internal static extern void AttachToProcessWithName_0(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr listener, global::System.IntPtr name, bool wait_for, global::System.IntPtr error);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?ConnectRemote@SBTarget@lldb@@QAE?AVSBProcess@2@AAVSBListener@2@PBD1AAVSBError@2@@Z")]
            internal static extern void ConnectRemote_0(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr listener, global::System.IntPtr url, global::System.IntPtr plugin_name, global::System.IntPtr error);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetExecutable@SBTarget@lldb@@QAE?AVSBFileSpec@2@XZ")]
            internal static extern void GetExecutable_0(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?AddModule@SBTarget@lldb@@QAE_NAAVSBModule@2@@Z")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool AddModule_0(global::System.IntPtr instance, global::System.IntPtr module);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?AddModule@SBTarget@lldb@@QAE?AVSBModule@2@PBD00@Z")]
            internal static extern void AddModule_1(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr path, global::System.IntPtr triple, global::System.IntPtr uuid);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?AddModule@SBTarget@lldb@@QAE?AVSBModule@2@PBD000@Z")]
            internal static extern void AddModule_2(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr path, global::System.IntPtr triple, global::System.IntPtr uuid_cstr, global::System.IntPtr symfile);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetModuleAtIndex@SBTarget@lldb@@QAE?AVSBModule@2@I@Z")]
            internal static extern void GetModuleAtIndex_0(global::System.IntPtr instance, global::System.IntPtr @return, uint idx);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?RemoveModule@SBTarget@lldb@@QAE_NVSBModule@2@@Z")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool RemoveModule_0(global::System.IntPtr instance, LLDB.Module.Internal module);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetDebugger@SBTarget@lldb@@QBE?AVSBDebugger@2@XZ")]
            internal static extern void GetDebugger_0(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?FindModule@SBTarget@lldb@@QAE?AVSBModule@2@ABVSBFileSpec@2@@Z")]
            internal static extern void FindModule_0(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr file_spec);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?SetSectionLoadAddress@SBTarget@lldb@@QAE?AVSBError@2@VSBSection@2@_K@Z")]
            internal static extern LLDB.Error.Internal SetSectionLoadAddress_0(global::System.IntPtr instance, LLDB.Section.Internal section, ulong section_base_addr);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?ClearSectionLoadAddress@SBTarget@lldb@@QAE?AVSBError@2@VSBSection@2@@Z")]
            internal static extern LLDB.Error.Internal ClearSectionLoadAddress_0(global::System.IntPtr instance, LLDB.Section.Internal section);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?SetModuleLoadAddress@SBTarget@lldb@@QAE?AVSBError@2@VSBModule@2@_J@Z")]
            internal static extern LLDB.Error.Internal SetModuleLoadAddress_0(global::System.IntPtr instance, LLDB.Module.Internal module, long sections_offset);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?ClearModuleLoadAddress@SBTarget@lldb@@QAE?AVSBError@2@VSBModule@2@@Z")]
            internal static extern LLDB.Error.Internal ClearModuleLoadAddress_0(global::System.IntPtr instance, LLDB.Module.Internal module);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?FindFunctions@SBTarget@lldb@@QAE?AVSBSymbolContextList@2@PBDI@Z")]
            internal static extern void FindFunctions_0(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr name, uint name_type_mask);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?FindGlobalVariables@SBTarget@lldb@@QAE?AVSBValueList@2@PBDI@Z")]
            internal static extern void FindGlobalVariables_0(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr name, uint max_matches);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?FindFirstGlobalVariable@SBTarget@lldb@@QAE?AVSBValue@2@PBD@Z")]
            internal static extern void FindFirstGlobalVariable_0(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?FindGlobalVariables@SBTarget@lldb@@QAE?AVSBValueList@2@PBDIW4MatchType@2@@Z")]
            internal static extern void FindGlobalVariables_1(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr name, uint max_matches, LLDB.MatchType matchtype);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?FindGlobalFunctions@SBTarget@lldb@@QAE?AVSBSymbolContextList@2@PBDIW4MatchType@2@@Z")]
            internal static extern void FindGlobalFunctions_0(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr name, uint max_matches, LLDB.MatchType matchtype);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?Clear@SBTarget@lldb@@QAEXXZ")]
            internal static extern void Clear_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?ResolveFileAddress@SBTarget@lldb@@QAE?AVSBAddress@2@_K@Z")]
            internal static extern void ResolveFileAddress_0(global::System.IntPtr instance, global::System.IntPtr @return, ulong file_addr);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?ResolveLoadAddress@SBTarget@lldb@@QAE?AVSBAddress@2@_K@Z")]
            internal static extern void ResolveLoadAddress_0(global::System.IntPtr instance, global::System.IntPtr @return, ulong vm_addr);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?ResolvePastLoadAddress@SBTarget@lldb@@QAE?AVSBAddress@2@I_K@Z")]
            internal static extern void ResolvePastLoadAddress_0(global::System.IntPtr instance, global::System.IntPtr @return, uint stop_id, ulong vm_addr);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?ResolveSymbolContextForAddress@SBTarget@lldb@@QAE?AVSBSymbolContext@2@ABVSBAddress@2@I@Z")]
            internal static extern void ResolveSymbolContextForAddress_0(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr addr, uint resolve_scope);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?ReadMemory@SBTarget@lldb@@QAEIVSBAddress@2@PAXIAAVSBError@2@@Z")]
            internal static extern uint ReadMemory_0(global::System.IntPtr instance, LLDB.Address.Internal addr, global::System.IntPtr buf, uint size, global::System.IntPtr error);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?BreakpointCreateByLocation@SBTarget@lldb@@QAE?AVSBBreakpoint@2@PBDI@Z")]
            internal static extern void BreakpointCreateByLocation_0(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr file, uint line);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?BreakpointCreateByLocation@SBTarget@lldb@@QAE?AVSBBreakpoint@2@ABVSBFileSpec@2@I@Z")]
            internal static extern void BreakpointCreateByLocation_1(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr file_spec, uint line);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?BreakpointCreateByName@SBTarget@lldb@@QAE?AVSBBreakpoint@2@PBD0@Z")]
            internal static extern void BreakpointCreateByName_0(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr symbol_name, global::System.IntPtr module_name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?BreakpointCreateByName@SBTarget@lldb@@QAE?AVSBBreakpoint@2@PBDABVSBFileSpecList@2@1@Z")]
            internal static extern void BreakpointCreateByName_1(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr symbol_name, global::System.IntPtr module_list, global::System.IntPtr comp_unit_list);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?BreakpointCreateByName@SBTarget@lldb@@QAE?AVSBBreakpoint@2@PBDIABVSBFileSpecList@2@1@Z")]
            internal static extern void BreakpointCreateByName_2(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr symbol_name, uint name_type_mask, global::System.IntPtr module_list, global::System.IntPtr comp_unit_list);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?BreakpointCreateByRegex@SBTarget@lldb@@QAE?AVSBBreakpoint@2@PBD0@Z")]
            internal static extern void BreakpointCreateByRegex_0(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr symbol_name_regex, global::System.IntPtr module_name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?BreakpointCreateByRegex@SBTarget@lldb@@QAE?AVSBBreakpoint@2@PBDABVSBFileSpecList@2@1@Z")]
            internal static extern void BreakpointCreateByRegex_1(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr symbol_name_regex, global::System.IntPtr module_list, global::System.IntPtr comp_unit_list);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?BreakpointCreateBySourceRegex@SBTarget@lldb@@QAE?AVSBBreakpoint@2@PBDABVSBFileSpec@2@0@Z")]
            internal static extern void BreakpointCreateBySourceRegex_0(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr source_regex, global::System.IntPtr source_file, global::System.IntPtr module_name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?BreakpointCreateBySourceRegex@SBTarget@lldb@@QAE?AVSBBreakpoint@2@PBDABVSBFileSpecList@2@1@Z")]
            internal static extern void BreakpointCreateBySourceRegex_1(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr source_regex, global::System.IntPtr module_list, global::System.IntPtr source_file);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?BreakpointCreateForException@SBTarget@lldb@@QAE?AVSBBreakpoint@2@W4LanguageType@2@_N1@Z")]
            internal static extern void BreakpointCreateForException_0(global::System.IntPtr instance, global::System.IntPtr @return, LLDB.LanguageType language, bool catch_bp, bool throw_bp);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?BreakpointCreateByAddress@SBTarget@lldb@@QAE?AVSBBreakpoint@2@_K@Z")]
            internal static extern void BreakpointCreateByAddress_0(global::System.IntPtr instance, global::System.IntPtr @return, ulong address);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetBreakpointAtIndex@SBTarget@lldb@@QBE?AVSBBreakpoint@2@I@Z")]
            internal static extern void GetBreakpointAtIndex_0(global::System.IntPtr instance, global::System.IntPtr @return, uint idx);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?BreakpointDelete@SBTarget@lldb@@QAE_NH@Z")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool BreakpointDelete_0(global::System.IntPtr instance, int break_id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?FindBreakpointByID@SBTarget@lldb@@QAE?AVSBBreakpoint@2@H@Z")]
            internal static extern void FindBreakpointByID_0(global::System.IntPtr instance, global::System.IntPtr @return, int break_id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?EnableAllBreakpoints@SBTarget@lldb@@QAE_NXZ")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool EnableAllBreakpoints_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?DisableAllBreakpoints@SBTarget@lldb@@QAE_NXZ")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool DisableAllBreakpoints_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?DeleteAllBreakpoints@SBTarget@lldb@@QAE_NXZ")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool DeleteAllBreakpoints_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetWatchpointAtIndex@SBTarget@lldb@@QBE?AVSBWatchpoint@2@I@Z")]
            internal static extern void GetWatchpointAtIndex_0(global::System.IntPtr instance, global::System.IntPtr @return, uint idx);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?DeleteWatchpoint@SBTarget@lldb@@QAE_NH@Z")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool DeleteWatchpoint_0(global::System.IntPtr instance, int watch_id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?FindWatchpointByID@SBTarget@lldb@@QAE?AVSBWatchpoint@2@H@Z")]
            internal static extern void FindWatchpointByID_0(global::System.IntPtr instance, global::System.IntPtr @return, int watch_id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?WatchAddress@SBTarget@lldb@@QAE?AVSBWatchpoint@2@_KI_N1AAVSBError@2@@Z")]
            internal static extern void WatchAddress_0(global::System.IntPtr instance, global::System.IntPtr @return, ulong addr, uint size, bool read, bool write, global::System.IntPtr error);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?EnableAllWatchpoints@SBTarget@lldb@@QAE_NXZ")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool EnableAllWatchpoints_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?DisableAllWatchpoints@SBTarget@lldb@@QAE_NXZ")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool DisableAllWatchpoints_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?DeleteAllWatchpoints@SBTarget@lldb@@QAE_NXZ")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool DeleteAllWatchpoints_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetBroadcaster@SBTarget@lldb@@QBE?AVSBBroadcaster@2@XZ")]
            internal static extern void GetBroadcaster_0(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?FindFirstType@SBTarget@lldb@@QAE?AVSBType@2@PBD@Z")]
            internal static extern void FindFirstType_0(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?FindTypes@SBTarget@lldb@@QAE?AVSBTypeList@2@PBD@Z")]
            internal static extern void FindTypes_0(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetBasicType@SBTarget@lldb@@QAE?AVSBType@2@W4BasicType@2@@Z")]
            internal static extern void GetBasicType_0(global::System.IntPtr instance, global::System.IntPtr @return, LLDB.BasicType type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?CreateValueFromAddress@SBTarget@lldb@@QAE?AVSBValue@2@PBDVSBAddress@2@VSBType@2@@Z")]
            internal static extern LLDB.Value.Internal CreateValueFromAddress_0(global::System.IntPtr instance, global::System.IntPtr name, LLDB.Address.Internal addr, LLDB.Type.Internal type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?CreateValueFromData@SBTarget@lldb@@QAE?AVSBValue@2@PBDVSBData@2@VSBType@2@@Z")]
            internal static extern LLDB.Value.Internal CreateValueFromData_0(global::System.IntPtr instance, global::System.IntPtr name, LLDB.Data.Internal data, LLDB.Type.Internal type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?CreateValueFromExpression@SBTarget@lldb@@QAE?AVSBValue@2@PBD0@Z")]
            internal static extern void CreateValueFromExpression_0(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr name, global::System.IntPtr expr);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetSourceManager@SBTarget@lldb@@QAE?AVSBSourceManager@2@XZ")]
            internal static extern void GetSourceManager_0(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?ReadInstructions@SBTarget@lldb@@QAE?AVSBInstructionList@2@VSBAddress@2@I@Z")]
            internal static extern LLDB.InstructionList.Internal ReadInstructions_0(global::System.IntPtr instance, LLDB.Address.Internal base_addr, uint count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?ReadInstructions@SBTarget@lldb@@QAE?AVSBInstructionList@2@VSBAddress@2@IPBD@Z")]
            internal static extern LLDB.InstructionList.Internal ReadInstructions_1(global::System.IntPtr instance, LLDB.Address.Internal base_addr, uint count, global::System.IntPtr flavor_string);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetInstructions@SBTarget@lldb@@QAE?AVSBInstructionList@2@VSBAddress@2@PBXI@Z")]
            internal static extern LLDB.InstructionList.Internal GetInstructions_0(global::System.IntPtr instance, LLDB.Address.Internal base_addr, global::System.IntPtr buf, uint size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetInstructionsWithFlavor@SBTarget@lldb@@QAE?AVSBInstructionList@2@VSBAddress@2@PBDPBXI@Z")]
            internal static extern LLDB.InstructionList.Internal GetInstructionsWithFlavor_0(global::System.IntPtr instance, LLDB.Address.Internal base_addr, global::System.IntPtr flavor_string, global::System.IntPtr buf, uint size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetInstructions@SBTarget@lldb@@QAE?AVSBInstructionList@2@_KPBXI@Z")]
            internal static extern void GetInstructions_1(global::System.IntPtr instance, global::System.IntPtr @return, ulong base_addr, global::System.IntPtr buf, uint size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetInstructionsWithFlavor@SBTarget@lldb@@QAE?AVSBInstructionList@2@_KPBDPBXI@Z")]
            internal static extern void GetInstructionsWithFlavor_1(global::System.IntPtr instance, global::System.IntPtr @return, ulong base_addr, global::System.IntPtr flavor_string, global::System.IntPtr buf, uint size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?FindSymbols@SBTarget@lldb@@QAE?AVSBSymbolContextList@2@PBDW4SymbolType@2@@Z")]
            internal static extern void FindSymbols_0(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr name, LLDB.SymbolType type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??8SBTarget@lldb@@QBE_NABV01@@Z")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr rhs);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??9SBTarget@lldb@@QBE_NABV01@@Z")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual_0(global::System.IntPtr instance, global::System.IntPtr rhs);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetDescription@SBTarget@lldb@@QAE_NAAVSBStream@2@W4DescriptionLevel@2@@Z")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool GetDescription_0(global::System.IntPtr instance, global::System.IntPtr description, LLDB.DescriptionLevel description_level);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?EvaluateExpression@SBTarget@lldb@@QAE?AVSBValue@2@PBD@Z")]
            internal static extern void EvaluateExpression_0(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr expr);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetLaunchInfo@SBTarget@lldb@@QBE?AVSBLaunchInfo@2@XZ")]
            internal static extern void GetLaunchInfo_0(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetBroadcasterClassName@SBTarget@lldb@@SAPBDXZ")]
            internal static extern global::System.IntPtr GetBroadcasterClassName_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetNumModules@SBTarget@lldb@@QBEIXZ")]
            internal static extern uint GetNumModules_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetByteOrder@SBTarget@lldb@@QAE?AW4ByteOrder@2@XZ")]
            internal static extern LLDB.ByteOrder GetByteOrder_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetAddressByteSize@SBTarget@lldb@@QAEIXZ")]
            internal static extern uint GetAddressByteSize_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetTriple@SBTarget@lldb@@QAEPBDXZ")]
            internal static extern global::System.IntPtr GetTriple_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetDataByteSize@SBTarget@lldb@@QAEIXZ")]
            internal static extern uint GetDataByteSize_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetCodeByteSize@SBTarget@lldb@@QAEIXZ")]
            internal static extern uint GetCodeByteSize_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetNumBreakpoints@SBTarget@lldb@@QBEIXZ")]
            internal static extern uint GetNumBreakpoints_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetNumWatchpoints@SBTarget@lldb@@QBEIXZ")]
            internal static extern uint GetNumWatchpoints_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetStackRedZoneSize@SBTarget@lldb@@QAE_KXZ")]
            internal static extern ulong GetStackRedZoneSize_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?SetLaunchInfo@SBTarget@lldb@@QAEXABVSBLaunchInfo@2@@Z")]
            internal static extern void SetLaunchInfo_0(global::System.IntPtr instance, global::System.IntPtr launch_info);
        }

        [Flags]
        public enum BroadcastBit
        {
            BroadcastBitBreakpointChanged = 1,
            BroadcastBitModulesLoaded = 2,
            BroadcastBitModulesUnloaded = 4,
            BroadcastBitWatchpointChanged = 8,
            BroadcastBitSymbolsLoaded = 16
        }

        public global::System.IntPtr __Instance { get; protected set; }
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Target> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Target>();

        private readonly bool __ownsNativeInstance;

        public static Target __CreateInstance(global::System.IntPtr native)
        {
            return new Target((Target.Internal*) native);
        }

        public static Target __CreateInstance(Target.Internal native)
        {
            return new Target(native);
        }

        private static Target.Internal* __CopyValue(Target.Internal native)
        {
            var ret = (Target.Internal*) Marshal.AllocHGlobal(8);
            *ret = native;
            return ret;
        }

        private Target(Target.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Target(Target.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        public Target()
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            Internal.ctor_0(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        protected virtual void Dispose(bool disposing)
        {
            DestroyNativeInstance(false);
        }

        public virtual void DestroyNativeInstance()
        {
            DestroyNativeInstance(true);
        }

        private void DestroyNativeInstance(bool force)
        {
            LLDB.Target __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance || force)
                Internal.dtor_0(__Instance, 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public bool IsValid()
        {
            var __ret = Internal.IsValid_0(__Instance);
            return __ret;
        }

        public LLDB.Process GetProcess()
        {
            var __ret = new LLDB.Process.Internal();
            Internal.GetProcess_0(__Instance, new IntPtr(&__ret));
            return LLDB.Process.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Return the platform object associated with the target.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// Return the platform object associated with the target.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// After return, the platform object should be checked
        /// for</para>
        /// <para></para>
        /// <para>    /// validity.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @return</para>
        /// <para></para>
        /// <para>    ///     A platform object.</para>
        /// </remarks>
        public LLDB.Platform GetPlatform()
        {
            var __ret = new LLDB.Platform.Internal();
            Internal.GetPlatform_0(__Instance, new IntPtr(&__ret));
            return LLDB.Platform.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Install any binaries that need to be installed.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// Install any binaries that need to be installed.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// This function does nothing when debugging on the host
        /// system.</para>
        /// <para></para>
        /// <para>    /// When connected to remote platforms, the target's main
        /// executable</para>
        /// <para></para>
        /// <para>    /// and any modules that have their remote install path set
        /// will be</para>
        /// <para></para>
        /// <para>    /// installed on the remote platform. If the main executable
        /// doesn't</para>
        /// <para></para>
        /// <para>    /// have an install location set, it will be installed in the
        /// remote</para>
        /// <para></para>
        /// <para>    /// platform's working directory.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @return</para>
        /// <para></para>
        /// <para>    ///     An error describing anything that went wrong
        /// during</para>
        /// <para></para>
        /// <para>    ///     installation.</para>
        /// </remarks>
        public LLDB.Error Install()
        {
            var __ret = new LLDB.Error.Internal();
            Internal.Install_0(__Instance, new IntPtr(&__ret));
            return LLDB.Error.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Launch a new process.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// Launch a new process.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// Launch a new process by spawning a new process using
        /// the</para>
        /// <para></para>
        /// <para>    /// target object's executable module's file as the file to
        /// launch.</para>
        /// <para></para>
        /// <para>    /// Arguments are given in \a argv, and the environment
        /// variables</para>
        /// <para></para>
        /// <para>    /// are in \a envp. Standard input and output files can
        /// be</para>
        /// <para></para>
        /// <para>    /// optionally re-directed to \a stdin_path, \a stdout_path,
        /// and</para>
        /// <para></para>
        /// <para>    /// \a stderr_path.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @param[in] listener</para>
        /// <para></para>
        /// <para>    ///     An optional listener that will receive all process
        /// events.</para>
        /// <para></para>
        /// <para>    ///     If \a listener is valid then \a listener will listen
        /// to all</para>
        /// <para></para>
        /// <para>    ///     process events. If not valid, then this target's
        /// debugger</para>
        /// <para></para>
        /// <para>    ///     (SBTarget::GetDebugger()) will listen to all process
        /// events. </para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @param[in] argv</para>
        /// <para></para>
        /// <para>    ///     The argument array.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @param[in] envp</para>
        /// <para></para>
        /// <para>    ///     The environment array.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @param[in] launch_flags</para>
        /// <para></para>
        /// <para>    ///     Flags to modify the launch (@see
        /// lldb::LaunchFlags)</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @param[in] stdin_path</para>
        /// <para></para>
        /// <para>    ///     The path to use when re-directing the STDIN of the
        /// new</para>
        /// <para></para>
        /// <para>    ///     process. If all stdXX_path arguments are NULL, a
        /// pseudo</para>
        /// <para></para>
        /// <para>    ///     terminal will be used.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @param[in] stdout_path</para>
        /// <para></para>
        /// <para>    ///     The path to use when re-directing the STDOUT of the
        /// new</para>
        /// <para></para>
        /// <para>    ///     process. If all stdXX_path arguments are NULL, a
        /// pseudo</para>
        /// <para></para>
        /// <para>    ///     terminal will be used.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @param[in] stderr_path</para>
        /// <para></para>
        /// <para>    ///     The path to use when re-directing the STDERR of the
        /// new</para>
        /// <para></para>
        /// <para>    ///     process. If all stdXX_path arguments are NULL, a
        /// pseudo</para>
        /// <para></para>
        /// <para>    ///     terminal will be used.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @param[in] working_directory</para>
        /// <para></para>
        /// <para>    ///     The working directory to have the child process run
        /// in</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @param[in] launch_flags</para>
        /// <para></para>
        /// <para>    ///     Some launch options specified by logical OR'ing
        /// </para>
        /// <para></para>
        /// <para>    ///     lldb::LaunchFlags enumeration values together.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @param[in] stop_at_entry</para>
        /// <para></para>
        /// <para>    ///     If false do not stop the inferior at the entry
        /// point.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @param[out] error</para>
        /// <para></para>
        /// <para>    ///     An error object. Contains the reason if there is some
        /// failure.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @return</para>
        /// <para></para>
        /// <para>    ///      A process object for the newly created
        /// process.</para>
        /// </remarks>
        public LLDB.Process Launch(LLDB.Listener listener, sbyte** argv, sbyte** envp, string stdin_path, string stdout_path, string stderr_path, string working_directory, uint launch_flags, bool stop_at_entry, LLDB.Error error)
        {
            var arg0 = ReferenceEquals(listener, null) ? global::System.IntPtr.Zero : listener.__Instance;
            var arg1 = argv;
            var arg2 = envp;
            var arg3 = Marshal.StringToHGlobalAnsi(stdin_path);
            var arg4 = Marshal.StringToHGlobalAnsi(stdout_path);
            var arg5 = Marshal.StringToHGlobalAnsi(stderr_path);
            var arg6 = Marshal.StringToHGlobalAnsi(working_directory);
            var arg7 = launch_flags;
            var arg9 = ReferenceEquals(error, null) ? global::System.IntPtr.Zero : error.__Instance;
            var __ret = new LLDB.Process.Internal();
            Internal.Launch_0(__Instance, new IntPtr(&__ret), arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, stop_at_entry, arg9);
            Marshal.FreeHGlobal(arg3);
            Marshal.FreeHGlobal(arg4);
            Marshal.FreeHGlobal(arg5);
            Marshal.FreeHGlobal(arg6);
            return LLDB.Process.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Launch a new process with sensible defaults.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// Launch a new process with sensible defaults.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @param[in] argv</para>
        /// <para></para>
        /// <para>    ///     The argument array.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @param[in] envp</para>
        /// <para></para>
        /// <para>    ///     The environment array.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @param[in] working_directory</para>
        /// <para></para>
        /// <para>    ///     The working directory to have the child process run
        /// in</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// Default: listener</para>
        /// <para></para>
        /// <para>    ///     Set to the target's debugger
        /// (SBTarget::GetDebugger())</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// Default: launch_flags</para>
        /// <para></para>
        /// <para>    ///     Empty launch flags</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// Default: stdin_path</para>
        /// <para></para>
        /// <para>    /// Default: stdout_path</para>
        /// <para></para>
        /// <para>    /// Default: stderr_path</para>
        /// <para></para>
        /// <para>    ///     A pseudo terminal will be used.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @return</para>
        /// <para></para>
        /// <para>    ///      A process object for the newly created
        /// process.</para>
        /// </remarks>
        public LLDB.Process LaunchSimple(sbyte** argv, sbyte** envp, string working_directory)
        {
            var arg0 = argv;
            var arg1 = envp;
            var arg2 = Marshal.StringToHGlobalAnsi(working_directory);
            var __ret = new LLDB.Process.Internal();
            Internal.LaunchSimple_0(__Instance, new IntPtr(&__ret), arg0, arg1, arg2);
            Marshal.FreeHGlobal(arg2);
            return LLDB.Process.__CreateInstance(__ret);
        }

        public LLDB.Process Launch(LLDB.LaunchInfo launch_info, LLDB.Error error)
        {
            var arg0 = ReferenceEquals(launch_info, null) ? global::System.IntPtr.Zero : launch_info.__Instance;
            var arg1 = ReferenceEquals(error, null) ? global::System.IntPtr.Zero : error.__Instance;
            var __ret = new LLDB.Process.Internal();
            Internal.Launch_1(__Instance, new IntPtr(&__ret), arg0, arg1);
            return LLDB.Process.__CreateInstance(__ret);
        }

        public LLDB.Process LoadCore(string core_file)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(core_file);
            var __ret = new LLDB.Process.Internal();
            Internal.LoadCore_0(__Instance, new IntPtr(&__ret), arg0);
            Marshal.FreeHGlobal(arg0);
            return LLDB.Process.__CreateInstance(__ret);
        }

        public LLDB.Process Attach(LLDB.AttachInfo attach_info, LLDB.Error error)
        {
            var arg0 = ReferenceEquals(attach_info, null) ? global::System.IntPtr.Zero : attach_info.__Instance;
            var arg1 = ReferenceEquals(error, null) ? global::System.IntPtr.Zero : error.__Instance;
            var __ret = new LLDB.Process.Internal();
            Internal.Attach_0(__Instance, new IntPtr(&__ret), arg0, arg1);
            return LLDB.Process.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Attach to process with pid.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// Attach to process with pid.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @param[in] listener</para>
        /// <para></para>
        /// <para>    ///     An optional listener that will receive all process
        /// events.</para>
        /// <para></para>
        /// <para>    ///     If \a listener is valid then \a listener will listen
        /// to all</para>
        /// <para></para>
        /// <para>    ///     process events. If not valid, then this target's
        /// debugger</para>
        /// <para></para>
        /// <para>    ///     (SBTarget::GetDebugger()) will listen to all process
        /// events.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @param[in] pid</para>
        /// <para></para>
        /// <para>    ///     The process ID to attach to.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @param[out] error</para>
        /// <para></para>
        /// <para>    ///     An error explaining what went wrong if attach
        /// fails.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @return</para>
        /// <para></para>
        /// <para>    ///      A process object for the attached process.</para>
        /// </remarks>
        public LLDB.Process AttachToProcessWithID(LLDB.Listener listener, ulong pid, LLDB.Error error)
        {
            var arg0 = ReferenceEquals(listener, null) ? global::System.IntPtr.Zero : listener.__Instance;
            var arg1 = pid;
            var arg2 = ReferenceEquals(error, null) ? global::System.IntPtr.Zero : error.__Instance;
            var __ret = new LLDB.Process.Internal();
            Internal.AttachToProcessWithID_0(__Instance, new IntPtr(&__ret), arg0, arg1, arg2);
            return LLDB.Process.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Attach to process with name.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// Attach to process with name.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @param[in] listener</para>
        /// <para></para>
        /// <para>    ///     An optional listener that will receive all process
        /// events.</para>
        /// <para></para>
        /// <para>    ///     If \a listener is valid then \a listener will listen
        /// to all</para>
        /// <para></para>
        /// <para>    ///     process events. If not valid, then this target's
        /// debugger</para>
        /// <para></para>
        /// <para>    ///     (SBTarget::GetDebugger()) will listen to all process
        /// events.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @param[in] name</para>
        /// <para></para>
        /// <para>    ///     Basename of process to attach to.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @param[in] wait_for</para>
        /// <para></para>
        /// <para>    ///     If true wait for a new instance of 'name' to be
        /// launched.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @param[out] error</para>
        /// <para></para>
        /// <para>    ///     An error explaining what went wrong if attach
        /// fails.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @return</para>
        /// <para></para>
        /// <para>    ///      A process object for the attached process.</para>
        /// </remarks>
        public LLDB.Process AttachToProcessWithName(LLDB.Listener listener, string name, bool wait_for, LLDB.Error error)
        {
            var arg0 = ReferenceEquals(listener, null) ? global::System.IntPtr.Zero : listener.__Instance;
            var arg1 = Marshal.StringToHGlobalAnsi(name);
            var arg3 = ReferenceEquals(error, null) ? global::System.IntPtr.Zero : error.__Instance;
            var __ret = new LLDB.Process.Internal();
            Internal.AttachToProcessWithName_0(__Instance, new IntPtr(&__ret), arg0, arg1, wait_for, arg3);
            Marshal.FreeHGlobal(arg1);
            return LLDB.Process.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Connect to a remote debug server with url.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// Connect to a remote debug server with url.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @param[in] listener</para>
        /// <para></para>
        /// <para>    ///     An optional listener that will receive all process
        /// events.</para>
        /// <para></para>
        /// <para>    ///     If \a listener is valid then \a listener will listen
        /// to all</para>
        /// <para></para>
        /// <para>    ///     process events. If not valid, then this target's
        /// debugger</para>
        /// <para></para>
        /// <para>    ///     (SBTarget::GetDebugger()) will listen to all process
        /// events.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @param[in] url</para>
        /// <para></para>
        /// <para>    ///     The url to connect to, e.g.,
        /// 'connect://localhost:12345'.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @param[in] plugin_name</para>
        /// <para></para>
        /// <para>    ///     The plugin name to be used; can be NULL.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @param[out] error</para>
        /// <para></para>
        /// <para>    ///     An error explaining what went wrong if the connect
        /// fails.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @return</para>
        /// <para></para>
        /// <para>    ///      A process object for the connected process.</para>
        /// </remarks>
        public LLDB.Process ConnectRemote(LLDB.Listener listener, string url, string plugin_name, LLDB.Error error)
        {
            var arg0 = ReferenceEquals(listener, null) ? global::System.IntPtr.Zero : listener.__Instance;
            var arg1 = Marshal.StringToHGlobalAnsi(url);
            var arg2 = Marshal.StringToHGlobalAnsi(plugin_name);
            var arg3 = ReferenceEquals(error, null) ? global::System.IntPtr.Zero : error.__Instance;
            var __ret = new LLDB.Process.Internal();
            Internal.ConnectRemote_0(__Instance, new IntPtr(&__ret), arg0, arg1, arg2, arg3);
            Marshal.FreeHGlobal(arg1);
            Marshal.FreeHGlobal(arg2);
            return LLDB.Process.__CreateInstance(__ret);
        }

        public LLDB.FileSpec GetExecutable()
        {
            var __ret = new LLDB.FileSpec.Internal();
            Internal.GetExecutable_0(__Instance, new IntPtr(&__ret));
            return LLDB.FileSpec.__CreateInstance(__ret);
        }

        public bool AddModule(LLDB.Module module)
        {
            var arg0 = ReferenceEquals(module, null) ? global::System.IntPtr.Zero : module.__Instance;
            var __ret = Internal.AddModule_0(__Instance, arg0);
            return __ret;
        }

        public LLDB.Module AddModule(string path, string triple, string uuid)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(path);
            var arg1 = Marshal.StringToHGlobalAnsi(triple);
            var arg2 = Marshal.StringToHGlobalAnsi(uuid);
            var __ret = new LLDB.Module.Internal();
            Internal.AddModule_1(__Instance, new IntPtr(&__ret), arg0, arg1, arg2);
            Marshal.FreeHGlobal(arg0);
            Marshal.FreeHGlobal(arg1);
            Marshal.FreeHGlobal(arg2);
            return LLDB.Module.__CreateInstance(__ret);
        }

        public LLDB.Module AddModule(string path, string triple, string uuid_cstr, string symfile)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(path);
            var arg1 = Marshal.StringToHGlobalAnsi(triple);
            var arg2 = Marshal.StringToHGlobalAnsi(uuid_cstr);
            var arg3 = Marshal.StringToHGlobalAnsi(symfile);
            var __ret = new LLDB.Module.Internal();
            Internal.AddModule_2(__Instance, new IntPtr(&__ret), arg0, arg1, arg2, arg3);
            Marshal.FreeHGlobal(arg0);
            Marshal.FreeHGlobal(arg1);
            Marshal.FreeHGlobal(arg2);
            Marshal.FreeHGlobal(arg3);
            return LLDB.Module.__CreateInstance(__ret);
        }

        public LLDB.Module GetModuleAtIndex(uint idx)
        {
            var arg0 = idx;
            var __ret = new LLDB.Module.Internal();
            Internal.GetModuleAtIndex_0(__Instance, new IntPtr(&__ret), arg0);
            return LLDB.Module.__CreateInstance(__ret);
        }

        public bool RemoveModule(LLDB.Module module)
        {
            var arg0 = ReferenceEquals(module, null) ? new LLDB.Module.Internal() : *(LLDB.Module.Internal*) (module.__Instance);
            var __ret = Internal.RemoveModule_0(__Instance, arg0);
            return __ret;
        }

        public LLDB.Debugger GetDebugger()
        {
            var __ret = new LLDB.Debugger.Internal();
            Internal.GetDebugger_0(__Instance, new IntPtr(&__ret));
            return LLDB.Debugger.__CreateInstance(__ret);
        }

        public LLDB.Module FindModule(LLDB.FileSpec file_spec)
        {
            var arg0 = ReferenceEquals(file_spec, null) ? global::System.IntPtr.Zero : file_spec.__Instance;
            var __ret = new LLDB.Module.Internal();
            Internal.FindModule_0(__Instance, new IntPtr(&__ret), arg0);
            return LLDB.Module.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Set the base load address for a module section.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// Set the base load address for a module section.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @param[in] section</para>
        /// <para></para>
        /// <para>    ///     The section whose base load address will be set
        /// within this</para>
        /// <para></para>
        /// <para>    ///     target.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @param[in] section_base_addr</para>
        /// <para></para>
        /// <para>    ///     The base address for the section.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @return</para>
        /// <para></para>
        /// <para>    ///      An error to indicate success, fail, and any reason
        /// for </para>
        /// <para></para>
        /// <para>    ///     failure.</para>
        /// </remarks>
        public LLDB.Error SetSectionLoadAddress(LLDB.Section section, ulong section_base_addr)
        {
            var arg0 = ReferenceEquals(section, null) ? new LLDB.Section.Internal() : *(LLDB.Section.Internal*) (section.__Instance);
            var arg1 = section_base_addr;
            var __ret = Internal.SetSectionLoadAddress_0(__Instance, arg0, arg1);
            return LLDB.Error.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Clear the base load address for a module section.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// Clear the base load address for a module section.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @param[in] section</para>
        /// <para></para>
        /// <para>    ///     The section whose base load address will be cleared
        /// within</para>
        /// <para></para>
        /// <para>    ///     this target.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @return</para>
        /// <para></para>
        /// <para>    ///      An error to indicate success, fail, and any reason
        /// for </para>
        /// <para></para>
        /// <para>    ///     failure.</para>
        /// </remarks>
        public LLDB.Error ClearSectionLoadAddress(LLDB.Section section)
        {
            var arg0 = ReferenceEquals(section, null) ? new LLDB.Section.Internal() : *(LLDB.Section.Internal*) (section.__Instance);
            var __ret = Internal.ClearSectionLoadAddress_0(__Instance, arg0);
            return LLDB.Error.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Slide all file addresses for all module sections so that module
        /// appears to loaded at these slide addresses.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// Slide all file addresses for all module sections so that \a
        /// module</para>
        /// <para></para>
        /// <para>    /// appears to loaded at these slide addresses.</para>
        /// <para></para>
        /// <para>    /// </para>
        /// <para></para>
        /// <para>    /// When you need all sections within a module to be loaded
        /// at a </para>
        /// <para></para>
        /// <para>    /// rigid slide from the addresses found in the module object
        /// file,</para>
        /// <para></para>
        /// <para>    /// this function will allow you to easily and quickly slide
        /// all</para>
        /// <para></para>
        /// <para>    /// module sections.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @param[in] module</para>
        /// <para></para>
        /// <para>    ///     The module to load.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @param[in] sections_offset</para>
        /// <para></para>
        /// <para>    ///     An offset that will be applied to all section file
        /// addresses</para>
        /// <para></para>
        /// <para>    ///     (the virtual addresses found in the object file
        /// itself).</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @return</para>
        /// <para></para>
        /// <para>    ///     An error to indicate success, fail, and any reason
        /// for </para>
        /// <para></para>
        /// <para>    ///     failure.</para>
        /// </remarks>
        public LLDB.Error SetModuleLoadAddress(LLDB.Module module, long sections_offset)
        {
            var arg0 = ReferenceEquals(module, null) ? new LLDB.Module.Internal() : *(LLDB.Module.Internal*) (module.__Instance);
            var arg1 = sections_offset;
            var __ret = Internal.SetModuleLoadAddress_0(__Instance, arg0, arg1);
            return LLDB.Error.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Clear the section base load addresses for all sections in a
        /// module.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// Clear the section base load addresses for all sections in a
        /// module.</para>
        /// <para></para>
        /// <para>    /// </para>
        /// <para></para>
        /// <para>    /// @param[in] module</para>
        /// <para></para>
        /// <para>    ///     The module to unload.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @return</para>
        /// <para></para>
        /// <para>    ///     An error to indicate success, fail, and any reason
        /// for </para>
        /// <para></para>
        /// <para>    ///     failure.</para>
        /// </remarks>
        public LLDB.Error ClearModuleLoadAddress(LLDB.Module module)
        {
            var arg0 = ReferenceEquals(module, null) ? new LLDB.Module.Internal() : *(LLDB.Module.Internal*) (module.__Instance);
            var __ret = Internal.ClearModuleLoadAddress_0(__Instance, arg0);
            return LLDB.Error.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Find functions by name.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// Find functions by name.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @param[in] name</para>
        /// <para></para>
        /// <para>    ///     The name of the function we are looking for.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @param[in] name_type_mask</para>
        /// <para></para>
        /// <para>    ///     A logical OR of one or more FunctionNameType enum
        /// bits that</para>
        /// <para></para>
        /// <para>    ///     indicate what kind of names should be used when doing
        /// the</para>
        /// <para></para>
        /// <para>    ///     lookup. Bits include fully qualified names, base
        /// names,</para>
        /// <para></para>
        /// <para>    ///     C++ methods, or ObjC selectors. </para>
        /// <para></para>
        /// <para>    ///     See FunctionNameType for more details.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @return</para>
        /// <para></para>
        /// <para>    ///     A lldb::SBSymbolContextList that gets filled in with
        /// all of </para>
        /// <para></para>
        /// <para>    ///     the symbol contexts for all the matches.</para>
        /// </remarks>
        public LLDB.SymbolContextList FindFunctions(string name, uint name_type_mask)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var arg1 = name_type_mask;
            var __ret = new LLDB.SymbolContextList.Internal();
            Internal.FindFunctions_0(__Instance, new IntPtr(&__ret), arg0, arg1);
            Marshal.FreeHGlobal(arg0);
            return LLDB.SymbolContextList.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Find global and static variables by name.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// Find global and static variables by name.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @param[in] name</para>
        /// <para></para>
        /// <para>    ///     The name of the global or static variable we are
        /// looking</para>
        /// <para></para>
        /// <para>    ///     for.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @param[in] max_matches</para>
        /// <para></para>
        /// <para>    ///     Allow the number of matches to be limited to \a
        /// max_matches.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @return</para>
        /// <para></para>
        /// <para>    ///     A list of matched variables in an SBValueList.</para>
        /// </remarks>
        public LLDB.ValueList FindGlobalVariables(string name, uint max_matches)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var arg1 = max_matches;
            var __ret = new LLDB.ValueList.Internal();
            Internal.FindGlobalVariables_0(__Instance, new IntPtr(&__ret), arg0, arg1);
            Marshal.FreeHGlobal(arg0);
            return LLDB.ValueList.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Find the first global (or static) variable by name.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// Find the first global (or static) variable by name.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @param[in] name</para>
        /// <para></para>
        /// <para>    ///     The name of the global or static variable we are
        /// looking</para>
        /// <para></para>
        /// <para>    ///     for.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @return</para>
        /// <para></para>
        /// <para>    ///     An SBValue that gets filled in with the found
        /// variable (if any).</para>
        /// </remarks>
        public LLDB.Value FindFirstGlobalVariable(string name)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var __ret = new LLDB.Value.Internal();
            Internal.FindFirstGlobalVariable_0(__Instance, new IntPtr(&__ret), arg0);
            Marshal.FreeHGlobal(arg0);
            return LLDB.Value.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Find global and static variables by pattern.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// Find global and static variables by pattern.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @param[in] name</para>
        /// <para></para>
        /// <para>    ///     The pattern to search for global or static
        /// variables</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @param[in] max_matches</para>
        /// <para></para>
        /// <para>    ///     Allow the number of matches to be limited to \a
        /// max_matches.</para>
        /// <para></para>
        /// <para>    /// </para>
        /// <para></para>
        /// <para>    /// @param[in] matchtype</para>
        /// <para></para>
        /// <para>    ///     The match type to use.    </para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @return</para>
        /// <para></para>
        /// <para>    ///     A list of matched variables in an SBValueList.</para>
        /// </remarks>
        public LLDB.ValueList FindGlobalVariables(string name, uint max_matches, LLDB.MatchType matchtype)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var arg1 = max_matches;
            var arg2 = matchtype;
            var __ret = new LLDB.ValueList.Internal();
            Internal.FindGlobalVariables_1(__Instance, new IntPtr(&__ret), arg0, arg1, arg2);
            Marshal.FreeHGlobal(arg0);
            return LLDB.ValueList.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Find global functions by their name with pattern matching.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// Find global functions by their name with pattern
        /// matching.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @param[in] name</para>
        /// <para></para>
        /// <para>    ///     The pattern to search for global or static
        /// variables</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @param[in] max_matches</para>
        /// <para></para>
        /// <para>    ///     Allow the number of matches to be limited to \a
        /// max_matches.</para>
        /// <para></para>
        /// <para>    /// </para>
        /// <para></para>
        /// <para>    /// @param[in] matchtype</para>
        /// <para></para>
        /// <para>    ///     The match type to use.    </para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @return</para>
        /// <para></para>
        /// <para>    ///     A list of matched variables in an SBValueList.</para>
        /// </remarks>
        public LLDB.SymbolContextList FindGlobalFunctions(string name, uint max_matches, LLDB.MatchType matchtype)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var arg1 = max_matches;
            var arg2 = matchtype;
            var __ret = new LLDB.SymbolContextList.Internal();
            Internal.FindGlobalFunctions_0(__Instance, new IntPtr(&__ret), arg0, arg1, arg2);
            Marshal.FreeHGlobal(arg0);
            return LLDB.SymbolContextList.__CreateInstance(__ret);
        }

        public void Clear()
        {
            Internal.Clear_0(__Instance);
        }

        /// <summary>
        /// <para>Resolve a current file address into a section offset
        /// address.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// Resolve a current file address into a section offset
        /// address.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @param[in] file_addr</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @return</para>
        /// <para></para>
        /// <para>    ///     An SBAddress which will be valid if...</para>
        /// </remarks>
        public LLDB.Address ResolveFileAddress(ulong file_addr)
        {
            var arg0 = file_addr;
            var __ret = new LLDB.Address.Internal();
            Internal.ResolveFileAddress_0(__Instance, new IntPtr(&__ret), arg0);
            return LLDB.Address.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Resolve a current load address into a section offset
        /// address.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// Resolve a current load address into a section offset
        /// address.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @param[in] vm_addr</para>
        /// <para></para>
        /// <para>    ///     A virtual address from the current process state that
        /// is to</para>
        /// <para></para>
        /// <para>    ///     be translated into a section offset address.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @return</para>
        /// <para></para>
        /// <para>    ///     An SBAddress which will be valid if \a vm_addr
        /// was</para>
        /// <para></para>
        /// <para>    ///     successfully resolved into a section offset address,
        /// or an</para>
        /// <para></para>
        /// <para>    ///     invalid SBAddress if \a vm_addr doesn't resolve to a
        /// section</para>
        /// <para></para>
        /// <para>    ///     in a module.</para>
        /// </remarks>
        public LLDB.Address ResolveLoadAddress(ulong vm_addr)
        {
            var arg0 = vm_addr;
            var __ret = new LLDB.Address.Internal();
            Internal.ResolveLoadAddress_0(__Instance, new IntPtr(&__ret), arg0);
            return LLDB.Address.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Resolve a current load address into a section offset address
        /// using the process stop ID to identify a time in the past.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// Resolve a current load address into a section offset
        /// address</para>
        /// <para></para>
        /// <para>    /// using the process stop ID to identify a time in the
        /// past.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @param[in] stop_id</para>
        /// <para></para>
        /// <para>    ///     Each time a process stops, the process stop ID
        /// integer gets</para>
        /// <para></para>
        /// <para>    ///     incremented. These stop IDs are used to identify past
        /// times</para>
        /// <para></para>
        /// <para>    ///     and can be used in history objects as a cheap way to
        /// store</para>
        /// <para></para>
        /// <para>    ///     the time at which the sample was taken.
        /// Specifying</para>
        /// <para></para>
        /// <para>    ///     UINT32_MAX will always resolve the address using
        /// the</para>
        /// <para></para>
        /// <para>    ///     currently loaded sections.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @param[in] vm_addr</para>
        /// <para></para>
        /// <para>    ///     A virtual address from the current process state that
        /// is to</para>
        /// <para></para>
        /// <para>    ///     be translated into a section offset address.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @return</para>
        /// <para></para>
        /// <para>    ///     An SBAddress which will be valid if \a vm_addr
        /// was</para>
        /// <para></para>
        /// <para>    ///     successfully resolved into a section offset address,
        /// or an</para>
        /// <para></para>
        /// <para>    ///     invalid SBAddress if \a vm_addr doesn't resolve to a
        /// section</para>
        /// <para></para>
        /// <para>    ///     in a module.</para>
        /// </remarks>
        public LLDB.Address ResolvePastLoadAddress(uint stop_id, ulong vm_addr)
        {
            var arg0 = stop_id;
            var arg1 = vm_addr;
            var __ret = new LLDB.Address.Internal();
            Internal.ResolvePastLoadAddress_0(__Instance, new IntPtr(&__ret), arg0, arg1);
            return LLDB.Address.__CreateInstance(__ret);
        }

        public LLDB.SymbolContext ResolveSymbolContextForAddress(LLDB.Address addr, uint resolve_scope)
        {
            var arg0 = ReferenceEquals(addr, null) ? global::System.IntPtr.Zero : addr.__Instance;
            var arg1 = resolve_scope;
            var __ret = new LLDB.SymbolContext.Internal();
            Internal.ResolveSymbolContextForAddress_0(__Instance, new IntPtr(&__ret), arg0, arg1);
            return LLDB.SymbolContext.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Read target memory. If a target process is running then memory is
        /// read from here. Otherwise the memory is read from the object files. For a
        /// target whose bytes are sized as a multiple of host bytes, the data read
        /// back will preserve the target's byte order.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// Read target memory. If a target process is running then
        /// memory  </para>
        /// <para></para>
        /// <para>    /// is read from here. Otherwise the memory is read from the
        /// object</para>
        /// <para></para>
        /// <para>    /// files. For a target whose bytes are sized as a multiple
        /// of host</para>
        /// <para></para>
        /// <para>    /// bytes, the data read back will preserve the target's byte
        /// order.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @param[in] addr</para>
        /// <para></para>
        /// <para>    ///     A target address to read from. </para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @param[out] buf</para>
        /// <para></para>
        /// <para>    ///     The buffer to read memory into. </para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @param[in] size</para>
        /// <para></para>
        /// <para>    ///     The maximum number of host bytes to read in the
        /// buffer passed</para>
        /// <para></para>
        /// <para>    ///     into this call</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @param[out] error</para>
        /// <para></para>
        /// <para>    ///     Error information is written here if the memory read
        /// fails.</para>
        /// <para></para>
        /// <para>    ///</para>
        /// <para></para>
        /// <para>    /// @return</para>
        /// <para></para>
        /// <para>    ///     The amount of data read in host bytes.</para>
        /// </remarks>
        public uint ReadMemory(LLDB.Address addr, global::System.IntPtr buf, uint size, LLDB.Error error)
        {
            var arg0 = ReferenceEquals(addr, null) ? new LLDB.Address.Internal() : *(LLDB.Address.Internal*) (addr.__Instance);
            var arg1 = buf;
            var arg2 = size;
            var arg3 = ReferenceEquals(error, null) ? global::System.IntPtr.Zero : error.__Instance;
            var __ret = Internal.ReadMemory_0(__Instance, arg0, arg1, arg2, arg3);
            return __ret;
        }

        public LLDB.Breakpoint BreakpointCreateByLocation(string file, uint line)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(file);
            var arg1 = line;
            var __ret = new LLDB.Breakpoint.Internal();
            Internal.BreakpointCreateByLocation_0(__Instance, new IntPtr(&__ret), arg0, arg1);
            Marshal.FreeHGlobal(arg0);
            return LLDB.Breakpoint.__CreateInstance(__ret);
        }

        public LLDB.Breakpoint BreakpointCreateByLocation(LLDB.FileSpec file_spec, uint line)
        {
            var arg0 = ReferenceEquals(file_spec, null) ? global::System.IntPtr.Zero : file_spec.__Instance;
            var arg1 = line;
            var __ret = new LLDB.Breakpoint.Internal();
            Internal.BreakpointCreateByLocation_1(__Instance, new IntPtr(&__ret), arg0, arg1);
            return LLDB.Breakpoint.__CreateInstance(__ret);
        }

        public LLDB.Breakpoint BreakpointCreateByName(string symbol_name, string module_name)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(symbol_name);
            var arg1 = Marshal.StringToHGlobalAnsi(module_name);
            var __ret = new LLDB.Breakpoint.Internal();
            Internal.BreakpointCreateByName_0(__Instance, new IntPtr(&__ret), arg0, arg1);
            Marshal.FreeHGlobal(arg0);
            Marshal.FreeHGlobal(arg1);
            return LLDB.Breakpoint.__CreateInstance(__ret);
        }

        public LLDB.Breakpoint BreakpointCreateByName(string symbol_name, LLDB.FileSpecList module_list, LLDB.FileSpecList comp_unit_list)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(symbol_name);
            var arg1 = ReferenceEquals(module_list, null) ? global::System.IntPtr.Zero : module_list.__Instance;
            var arg2 = ReferenceEquals(comp_unit_list, null) ? global::System.IntPtr.Zero : comp_unit_list.__Instance;
            var __ret = new LLDB.Breakpoint.Internal();
            Internal.BreakpointCreateByName_1(__Instance, new IntPtr(&__ret), arg0, arg1, arg2);
            Marshal.FreeHGlobal(arg0);
            return LLDB.Breakpoint.__CreateInstance(__ret);
        }

        public LLDB.Breakpoint BreakpointCreateByName(string symbol_name, uint name_type_mask, LLDB.FileSpecList module_list, LLDB.FileSpecList comp_unit_list)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(symbol_name);
            var arg1 = name_type_mask;
            var arg2 = ReferenceEquals(module_list, null) ? global::System.IntPtr.Zero : module_list.__Instance;
            var arg3 = ReferenceEquals(comp_unit_list, null) ? global::System.IntPtr.Zero : comp_unit_list.__Instance;
            var __ret = new LLDB.Breakpoint.Internal();
            Internal.BreakpointCreateByName_2(__Instance, new IntPtr(&__ret), arg0, arg1, arg2, arg3);
            Marshal.FreeHGlobal(arg0);
            return LLDB.Breakpoint.__CreateInstance(__ret);
        }

        public LLDB.Breakpoint BreakpointCreateByRegex(string symbol_name_regex, string module_name)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(symbol_name_regex);
            var arg1 = Marshal.StringToHGlobalAnsi(module_name);
            var __ret = new LLDB.Breakpoint.Internal();
            Internal.BreakpointCreateByRegex_0(__Instance, new IntPtr(&__ret), arg0, arg1);
            Marshal.FreeHGlobal(arg0);
            Marshal.FreeHGlobal(arg1);
            return LLDB.Breakpoint.__CreateInstance(__ret);
        }

        public LLDB.Breakpoint BreakpointCreateByRegex(string symbol_name_regex, LLDB.FileSpecList module_list, LLDB.FileSpecList comp_unit_list)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(symbol_name_regex);
            var arg1 = ReferenceEquals(module_list, null) ? global::System.IntPtr.Zero : module_list.__Instance;
            var arg2 = ReferenceEquals(comp_unit_list, null) ? global::System.IntPtr.Zero : comp_unit_list.__Instance;
            var __ret = new LLDB.Breakpoint.Internal();
            Internal.BreakpointCreateByRegex_1(__Instance, new IntPtr(&__ret), arg0, arg1, arg2);
            Marshal.FreeHGlobal(arg0);
            return LLDB.Breakpoint.__CreateInstance(__ret);
        }

        public LLDB.Breakpoint BreakpointCreateBySourceRegex(string source_regex, LLDB.FileSpec source_file, string module_name)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(source_regex);
            var arg1 = ReferenceEquals(source_file, null) ? global::System.IntPtr.Zero : source_file.__Instance;
            var arg2 = Marshal.StringToHGlobalAnsi(module_name);
            var __ret = new LLDB.Breakpoint.Internal();
            Internal.BreakpointCreateBySourceRegex_0(__Instance, new IntPtr(&__ret), arg0, arg1, arg2);
            Marshal.FreeHGlobal(arg0);
            Marshal.FreeHGlobal(arg2);
            return LLDB.Breakpoint.__CreateInstance(__ret);
        }

        public LLDB.Breakpoint BreakpointCreateBySourceRegex(string source_regex, LLDB.FileSpecList module_list, LLDB.FileSpecList source_file)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(source_regex);
            var arg1 = ReferenceEquals(module_list, null) ? global::System.IntPtr.Zero : module_list.__Instance;
            var arg2 = ReferenceEquals(source_file, null) ? global::System.IntPtr.Zero : source_file.__Instance;
            var __ret = new LLDB.Breakpoint.Internal();
            Internal.BreakpointCreateBySourceRegex_1(__Instance, new IntPtr(&__ret), arg0, arg1, arg2);
            Marshal.FreeHGlobal(arg0);
            return LLDB.Breakpoint.__CreateInstance(__ret);
        }

        public LLDB.Breakpoint BreakpointCreateForException(LLDB.LanguageType language, bool catch_bp, bool throw_bp)
        {
            var arg0 = language;
            var __ret = new LLDB.Breakpoint.Internal();
            Internal.BreakpointCreateForException_0(__Instance, new IntPtr(&__ret), arg0, catch_bp, throw_bp);
            return LLDB.Breakpoint.__CreateInstance(__ret);
        }

        public LLDB.Breakpoint BreakpointCreateByAddress(ulong address)
        {
            var arg0 = address;
            var __ret = new LLDB.Breakpoint.Internal();
            Internal.BreakpointCreateByAddress_0(__Instance, new IntPtr(&__ret), arg0);
            return LLDB.Breakpoint.__CreateInstance(__ret);
        }

        public LLDB.Breakpoint GetBreakpointAtIndex(uint idx)
        {
            var arg0 = idx;
            var __ret = new LLDB.Breakpoint.Internal();
            Internal.GetBreakpointAtIndex_0(__Instance, new IntPtr(&__ret), arg0);
            return LLDB.Breakpoint.__CreateInstance(__ret);
        }

        public bool BreakpointDelete(int break_id)
        {
            var arg0 = break_id;
            var __ret = Internal.BreakpointDelete_0(__Instance, arg0);
            return __ret;
        }

        public LLDB.Breakpoint FindBreakpointByID(int break_id)
        {
            var arg0 = break_id;
            var __ret = new LLDB.Breakpoint.Internal();
            Internal.FindBreakpointByID_0(__Instance, new IntPtr(&__ret), arg0);
            return LLDB.Breakpoint.__CreateInstance(__ret);
        }

        public bool EnableAllBreakpoints()
        {
            var __ret = Internal.EnableAllBreakpoints_0(__Instance);
            return __ret;
        }

        public bool DisableAllBreakpoints()
        {
            var __ret = Internal.DisableAllBreakpoints_0(__Instance);
            return __ret;
        }

        public bool DeleteAllBreakpoints()
        {
            var __ret = Internal.DeleteAllBreakpoints_0(__Instance);
            return __ret;
        }

        public LLDB.Watchpoint GetWatchpointAtIndex(uint idx)
        {
            var arg0 = idx;
            var __ret = new LLDB.Watchpoint.Internal();
            Internal.GetWatchpointAtIndex_0(__Instance, new IntPtr(&__ret), arg0);
            return LLDB.Watchpoint.__CreateInstance(__ret);
        }

        public bool DeleteWatchpoint(int watch_id)
        {
            var arg0 = watch_id;
            var __ret = Internal.DeleteWatchpoint_0(__Instance, arg0);
            return __ret;
        }

        public LLDB.Watchpoint FindWatchpointByID(int watch_id)
        {
            var arg0 = watch_id;
            var __ret = new LLDB.Watchpoint.Internal();
            Internal.FindWatchpointByID_0(__Instance, new IntPtr(&__ret), arg0);
            return LLDB.Watchpoint.__CreateInstance(__ret);
        }

        public LLDB.Watchpoint WatchAddress(ulong addr, uint size, bool read, bool write, LLDB.Error error)
        {
            var arg0 = addr;
            var arg1 = size;
            var arg4 = ReferenceEquals(error, null) ? global::System.IntPtr.Zero : error.__Instance;
            var __ret = new LLDB.Watchpoint.Internal();
            Internal.WatchAddress_0(__Instance, new IntPtr(&__ret), arg0, arg1, read, write, arg4);
            return LLDB.Watchpoint.__CreateInstance(__ret);
        }

        public bool EnableAllWatchpoints()
        {
            var __ret = Internal.EnableAllWatchpoints_0(__Instance);
            return __ret;
        }

        public bool DisableAllWatchpoints()
        {
            var __ret = Internal.DisableAllWatchpoints_0(__Instance);
            return __ret;
        }

        public bool DeleteAllWatchpoints()
        {
            var __ret = Internal.DeleteAllWatchpoints_0(__Instance);
            return __ret;
        }

        public LLDB.Broadcaster GetBroadcaster()
        {
            var __ret = new LLDB.Broadcaster.Internal();
            Internal.GetBroadcaster_0(__Instance, new IntPtr(&__ret));
            return LLDB.Broadcaster.__CreateInstance(__ret);
        }

        public LLDB.Type FindFirstType(string type)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(type);
            var __ret = new LLDB.Type.Internal();
            Internal.FindFirstType_0(__Instance, new IntPtr(&__ret), arg0);
            Marshal.FreeHGlobal(arg0);
            return LLDB.Type.__CreateInstance(__ret);
        }

        public LLDB.TypeList FindTypes(string type)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(type);
            var __ret = new LLDB.TypeList.Internal();
            Internal.FindTypes_0(__Instance, new IntPtr(&__ret), arg0);
            Marshal.FreeHGlobal(arg0);
            return LLDB.TypeList.__CreateInstance(__ret);
        }

        public LLDB.Type GetBasicType(LLDB.BasicType type)
        {
            var arg0 = type;
            var __ret = new LLDB.Type.Internal();
            Internal.GetBasicType_0(__Instance, new IntPtr(&__ret), arg0);
            return LLDB.Type.__CreateInstance(__ret);
        }

        public LLDB.Value CreateValueFromAddress(string name, LLDB.Address addr, LLDB.Type type)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var arg1 = ReferenceEquals(addr, null) ? new LLDB.Address.Internal() : *(LLDB.Address.Internal*) (addr.__Instance);
            var arg2 = ReferenceEquals(type, null) ? new LLDB.Type.Internal() : *(LLDB.Type.Internal*) (type.__Instance);
            var __ret = Internal.CreateValueFromAddress_0(__Instance, arg0, arg1, arg2);
            Marshal.FreeHGlobal(arg0);
            return LLDB.Value.__CreateInstance(__ret);
        }

        public LLDB.Value CreateValueFromData(string name, LLDB.Data data, LLDB.Type type)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var arg1 = ReferenceEquals(data, null) ? new LLDB.Data.Internal() : *(LLDB.Data.Internal*) (data.__Instance);
            var arg2 = ReferenceEquals(type, null) ? new LLDB.Type.Internal() : *(LLDB.Type.Internal*) (type.__Instance);
            var __ret = Internal.CreateValueFromData_0(__Instance, arg0, arg1, arg2);
            Marshal.FreeHGlobal(arg0);
            return LLDB.Value.__CreateInstance(__ret);
        }

        public LLDB.Value CreateValueFromExpression(string name, string expr)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var arg1 = Marshal.StringToHGlobalAnsi(expr);
            var __ret = new LLDB.Value.Internal();
            Internal.CreateValueFromExpression_0(__Instance, new IntPtr(&__ret), arg0, arg1);
            Marshal.FreeHGlobal(arg0);
            Marshal.FreeHGlobal(arg1);
            return LLDB.Value.__CreateInstance(__ret);
        }

        public LLDB.SourceManager GetSourceManager()
        {
            var __ret = new LLDB.SourceManager.Internal();
            Internal.GetSourceManager_0(__Instance, new IntPtr(&__ret));
            return LLDB.SourceManager.__CreateInstance(__ret);
        }

        public LLDB.InstructionList ReadInstructions(LLDB.Address base_addr, uint count)
        {
            var arg0 = ReferenceEquals(base_addr, null) ? new LLDB.Address.Internal() : *(LLDB.Address.Internal*) (base_addr.__Instance);
            var arg1 = count;
            var __ret = Internal.ReadInstructions_0(__Instance, arg0, arg1);
            return LLDB.InstructionList.__CreateInstance(__ret);
        }

        public LLDB.InstructionList ReadInstructions(LLDB.Address base_addr, uint count, string flavor_string)
        {
            var arg0 = ReferenceEquals(base_addr, null) ? new LLDB.Address.Internal() : *(LLDB.Address.Internal*) (base_addr.__Instance);
            var arg1 = count;
            var arg2 = Marshal.StringToHGlobalAnsi(flavor_string);
            var __ret = Internal.ReadInstructions_1(__Instance, arg0, arg1, arg2);
            Marshal.FreeHGlobal(arg2);
            return LLDB.InstructionList.__CreateInstance(__ret);
        }

        public LLDB.InstructionList GetInstructions(LLDB.Address base_addr, global::System.IntPtr buf, uint size)
        {
            var arg0 = ReferenceEquals(base_addr, null) ? new LLDB.Address.Internal() : *(LLDB.Address.Internal*) (base_addr.__Instance);
            var arg1 = buf;
            var arg2 = size;
            var __ret = Internal.GetInstructions_0(__Instance, arg0, arg1, arg2);
            return LLDB.InstructionList.__CreateInstance(__ret);
        }

        public LLDB.InstructionList GetInstructionsWithFlavor(LLDB.Address base_addr, string flavor_string, global::System.IntPtr buf, uint size)
        {
            var arg0 = ReferenceEquals(base_addr, null) ? new LLDB.Address.Internal() : *(LLDB.Address.Internal*) (base_addr.__Instance);
            var arg1 = Marshal.StringToHGlobalAnsi(flavor_string);
            var arg2 = buf;
            var arg3 = size;
            var __ret = Internal.GetInstructionsWithFlavor_0(__Instance, arg0, arg1, arg2, arg3);
            Marshal.FreeHGlobal(arg1);
            return LLDB.InstructionList.__CreateInstance(__ret);
        }

        public LLDB.InstructionList GetInstructions(ulong base_addr, global::System.IntPtr buf, uint size)
        {
            var arg0 = base_addr;
            var arg1 = buf;
            var arg2 = size;
            var __ret = new LLDB.InstructionList.Internal();
            Internal.GetInstructions_1(__Instance, new IntPtr(&__ret), arg0, arg1, arg2);
            return LLDB.InstructionList.__CreateInstance(__ret);
        }

        public LLDB.InstructionList GetInstructionsWithFlavor(ulong base_addr, string flavor_string, global::System.IntPtr buf, uint size)
        {
            var arg0 = base_addr;
            var arg1 = Marshal.StringToHGlobalAnsi(flavor_string);
            var arg2 = buf;
            var arg3 = size;
            var __ret = new LLDB.InstructionList.Internal();
            Internal.GetInstructionsWithFlavor_1(__Instance, new IntPtr(&__ret), arg0, arg1, arg2, arg3);
            Marshal.FreeHGlobal(arg1);
            return LLDB.InstructionList.__CreateInstance(__ret);
        }

        public LLDB.SymbolContextList FindSymbols(string name, LLDB.SymbolType type)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var arg1 = type;
            var __ret = new LLDB.SymbolContextList.Internal();
            Internal.FindSymbols_0(__Instance, new IntPtr(&__ret), arg0, arg1);
            Marshal.FreeHGlobal(arg0);
            return LLDB.SymbolContextList.__CreateInstance(__ret);
        }

        public static bool operator ==(LLDB.Target __op, LLDB.Target rhs)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool rhsNull = ReferenceEquals(rhs, null);
            if (__opNull || rhsNull)
                return __opNull && rhsNull;
            var arg0 = __op.__Instance;
            var arg1 = rhs.__Instance;
            var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as Target;
        }

        public static bool operator !=(LLDB.Target __op, LLDB.Target rhs)
        {
            var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
            var arg1 = ReferenceEquals(rhs, null) ? global::System.IntPtr.Zero : rhs.__Instance;
            var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
            return __ret;
        }

        public bool GetDescription(LLDB.Stream description, LLDB.DescriptionLevel description_level)
        {
            var arg0 = ReferenceEquals(description, null) ? global::System.IntPtr.Zero : description.__Instance;
            var arg1 = description_level;
            var __ret = Internal.GetDescription_0(__Instance, arg0, arg1);
            return __ret;
        }

        public LLDB.Value EvaluateExpression(string expr)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(expr);
            var __ret = new LLDB.Value.Internal();
            Internal.EvaluateExpression_0(__Instance, new IntPtr(&__ret), arg0);
            Marshal.FreeHGlobal(arg0);
            return LLDB.Value.__CreateInstance(__ret);
        }

        public LLDB.LaunchInfo GetLaunchInfo()
        {
            var __ret = new LLDB.LaunchInfo.Internal();
            Internal.GetLaunchInfo_0(__Instance, new IntPtr(&__ret));
            return LLDB.LaunchInfo.__CreateInstance(__ret);
        }

        public static bool EventIsTargetEvent(LLDB.Event @event)
        {
            var arg0 = ReferenceEquals(@event, null) ? global::System.IntPtr.Zero : @event.__Instance;
            var __ret = Internal.EventIsTargetEvent_0(arg0);
            return __ret;
        }

        public static LLDB.Target GetTargetFromEvent(LLDB.Event @event)
        {
            var arg0 = ReferenceEquals(@event, null) ? global::System.IntPtr.Zero : @event.__Instance;
            var __ret = new LLDB.Target.Internal();
            Internal.GetTargetFromEvent_0(new IntPtr(&__ret), arg0);
            return LLDB.Target.__CreateInstance(__ret);
        }

        public static uint GetNumModulesFromEvent(LLDB.Event @event)
        {
            var arg0 = ReferenceEquals(@event, null) ? global::System.IntPtr.Zero : @event.__Instance;
            var __ret = Internal.GetNumModulesFromEvent_0(arg0);
            return __ret;
        }

        public static LLDB.Module GetModuleAtIndexFromEvent(uint idx, LLDB.Event @event)
        {
            var arg0 = idx;
            var arg1 = ReferenceEquals(@event, null) ? global::System.IntPtr.Zero : @event.__Instance;
            var __ret = new LLDB.Module.Internal();
            Internal.GetModuleAtIndexFromEvent_0(new IntPtr(&__ret), arg0, arg1);
            return LLDB.Module.__CreateInstance(__ret);
        }

        public static string BroadcasterClassName
        {
            get
            {
                var __ret = Internal.GetBroadcasterClassName_0();
                return Marshal.PtrToStringAnsi(__ret);
            }
        }

        public uint NumModules
        {
            get
            {
                var __ret = Internal.GetNumModules_0(__Instance);
                return __ret;
            }
        }

        public LLDB.ByteOrder ByteOrder
        {
            get
            {
                var __ret = Internal.GetByteOrder_0(__Instance);
                return __ret;
            }
        }

        public uint AddressByteSize
        {
            get
            {
                var __ret = Internal.GetAddressByteSize_0(__Instance);
                return __ret;
            }
        }

        public string Triple
        {
            get
            {
                var __ret = Internal.GetTriple_0(__Instance);
                return Marshal.PtrToStringAnsi(__ret);
            }
        }

        public uint DataByteSize
        {
            get
            {
                var __ret = Internal.GetDataByteSize_0(__Instance);
                return __ret;
            }
        }

        public uint CodeByteSize
        {
            get
            {
                var __ret = Internal.GetCodeByteSize_0(__Instance);
                return __ret;
            }
        }

        public uint NumBreakpoints
        {
            get
            {
                var __ret = Internal.GetNumBreakpoints_0(__Instance);
                return __ret;
            }
        }

        public uint NumWatchpoints
        {
            get
            {
                var __ret = Internal.GetNumWatchpoints_0(__Instance);
                return __ret;
            }
        }

        public ulong StackRedZoneSize
        {
            get
            {
                var __ret = Internal.GetStackRedZoneSize_0(__Instance);
                return __ret;
            }
        }

        public LLDB.LaunchInfo LaunchInfo
        {
            set
            {
                var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                Internal.SetLaunchInfo_0(__Instance, arg0);
            }
        }
    }
}
