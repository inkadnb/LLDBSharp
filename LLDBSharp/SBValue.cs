//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace LLDB
{
    public unsafe partial class Value : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValueC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValueC2ERKS0_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr rhs);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValueD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue7IsValidEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsValid_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue5ClearEv")]
            internal static extern void Clear_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue8GetErrorEv")]
            internal static extern void GetError_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue9IsInScopeEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsInScope_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue16GetValueAsSignedERNS_7SBErrorEx")]
            internal static extern long GetValueAsSigned_0(global::System.IntPtr instance, global::System.IntPtr error, long fail_value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue18GetValueAsUnsignedERNS_7SBErrorEy")]
            internal static extern ulong GetValueAsUnsigned_0(global::System.IntPtr instance, global::System.IntPtr error, ulong fail_value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue16GetValueAsSignedEx")]
            internal static extern long GetValueAsSigned_1(global::System.IntPtr instance, long fail_value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue18GetValueAsUnsignedEy")]
            internal static extern ulong GetValueAsUnsigned_1(global::System.IntPtr instance, ulong fail_value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue15GetDynamicValueENS_16DynamicValueTypeE")]
            internal static extern void GetDynamicValue_0(global::System.IntPtr @return, global::System.IntPtr instance, LLDB.DynamicValueType use_dynamic);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue14GetStaticValueEv")]
            internal static extern void GetStaticValue_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue20GetNonSyntheticValueEv")]
            internal static extern void GetNonSyntheticValue_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue9IsDynamicEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsDynamic_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue11IsSyntheticEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsSynthetic_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue19SetValueFromCStringEPKc")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool SetValueFromCString_0(global::System.IntPtr instance, global::System.IntPtr value_str);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue19SetValueFromCStringEPKcRNS_7SBErrorE")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool SetValueFromCString_1(global::System.IntPtr instance, global::System.IntPtr value_str, global::System.IntPtr error);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue15GetChildAtIndexEj")]
            internal static extern void GetChildAtIndex_0(global::System.IntPtr @return, global::System.IntPtr instance, uint idx);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue19CreateChildAtOffsetEPKcjNS_6SBTypeE")]
            internal static extern void CreateChildAtOffset_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr name, uint offset, LLDB.Type.Internal type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue4CastENS_6SBTypeE")]
            internal static extern void Cast_0(global::System.IntPtr @return, global::System.IntPtr instance, LLDB.Type.Internal type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue25CreateValueFromExpressionEPKcS2_")]
            internal static extern void CreateValueFromExpression_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr name, global::System.IntPtr expression);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue22CreateValueFromAddressEPKcyNS_6SBTypeE")]
            internal static extern void CreateValueFromAddress_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr name, ulong address, LLDB.Type.Internal type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue19CreateValueFromDataEPKcNS_6SBDataENS_6SBTypeE")]
            internal static extern void CreateValueFromData_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr name, LLDB.Data.Internal data, LLDB.Type.Internal type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue15GetChildAtIndexEjNS_16DynamicValueTypeEb")]
            internal static extern void GetChildAtIndex_1(global::System.IntPtr @return, global::System.IntPtr instance, uint idx, LLDB.DynamicValueType use_dynamic, bool can_create_synthetic);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue23GetIndexOfChildWithNameEPKc")]
            internal static extern uint GetIndexOfChildWithName_0(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue22GetChildMemberWithNameEPKc")]
            internal static extern void GetChildMemberWithName_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue22GetChildMemberWithNameEPKcNS_16DynamicValueTypeE")]
            internal static extern void GetChildMemberWithName_1(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr name, LLDB.DynamicValueType use_dynamic);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue25GetValueForExpressionPathEPKc")]
            internal static extern void GetValueForExpressionPath_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr expr_path);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue9AddressOfEv")]
            internal static extern void AddressOf_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue10GetAddressEv")]
            internal static extern void GetAddress_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue14GetPointeeDataEjj")]
            internal static extern void GetPointeeData_0(global::System.IntPtr @return, global::System.IntPtr instance, uint item_idx, uint item_count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue7GetDataEv")]
            internal static extern void GetData_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue7SetDataERNS_6SBDataERNS_7SBErrorE")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool SetData_0(global::System.IntPtr instance, global::System.IntPtr data, global::System.IntPtr error);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue14GetDeclarationEv")]
            internal static extern void GetDeclaration_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue17MightHaveChildrenEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool MightHaveChildren_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue21IsRuntimeSupportValueEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsRuntimeSupportValue_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue9GetTargetEv")]
            internal static extern void GetTarget_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue10GetProcessEv")]
            internal static extern void GetProcess_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue9GetThreadEv")]
            internal static extern void GetThread_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue8GetFrameEv")]
            internal static extern void GetFrame_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue11DereferenceEv")]
            internal static extern void Dereference_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue17TypeIsPointerTypeEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool TypeIsPointerType_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue7GetTypeEv")]
            internal static extern void GetType_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue7PersistEv")]
            internal static extern void Persist_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue14GetDescriptionERNS_8SBStreamE")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool GetDescription_0(global::System.IntPtr instance, global::System.IntPtr description);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue17GetExpressionPathERNS_8SBStreamE")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool GetExpressionPath_0(global::System.IntPtr instance, global::System.IntPtr description);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue17GetExpressionPathERNS_8SBStreamEb")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool GetExpressionPath_1(global::System.IntPtr instance, global::System.IntPtr description, bool qualify_cxx_base_classes);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue5WatchEbbbRNS_7SBErrorE")]
            internal static extern void Watch_0(global::System.IntPtr @return, global::System.IntPtr instance, bool resolve_location, bool read, bool write, global::System.IntPtr error);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue5WatchEbbb")]
            internal static extern void Watch_1(global::System.IntPtr @return, global::System.IntPtr instance, bool resolve_location, bool read, bool write);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue12WatchPointeeEbbbRNS_7SBErrorE")]
            internal static extern void WatchPointee_0(global::System.IntPtr @return, global::System.IntPtr instance, bool resolve_location, bool read, bool write, global::System.IntPtr error);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue5GetIDEv")]
            internal static extern ulong GetID_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue7GetNameEv")]
            internal static extern global::System.IntPtr GetName_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue11GetTypeNameEv")]
            internal static extern global::System.IntPtr GetTypeName_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue18GetDisplayTypeNameEv")]
            internal static extern global::System.IntPtr GetDisplayTypeName_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue11GetByteSizeEv")]
            internal static extern uint GetByteSize_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue9GetFormatEv")]
            internal static extern LLDB.Format GetFormat_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue9SetFormatENS_6FormatE")]
            internal static extern void SetFormat_0(global::System.IntPtr instance, LLDB.Format format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue8GetValueEv")]
            internal static extern global::System.IntPtr GetValueAsString_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue12GetValueTypeEv")]
            internal static extern LLDB.ValueType GetValueType_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue17GetValueDidChangeEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool GetValueDidChange_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue10GetSummaryEv")]
            internal static extern global::System.IntPtr GetSummary_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue20GetObjectDescriptionEv")]
            internal static extern global::System.IntPtr GetObjectDescription_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue22GetTypeValidatorResultEv")]
            internal static extern global::System.IntPtr GetTypeValidatorResult_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue21GetPreferDynamicValueEv")]
            internal static extern LLDB.DynamicValueType GetPreferDynamicValue_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue21SetPreferDynamicValueENS_16DynamicValueTypeE")]
            internal static extern void SetPreferDynamicValue_0(global::System.IntPtr instance, LLDB.DynamicValueType use_dynamic);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue23GetPreferSyntheticValueEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool GetPreferSyntheticValue_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue23SetPreferSyntheticValueEb")]
            internal static extern void SetPreferSyntheticValue_0(global::System.IntPtr instance, bool use_synthetic);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue11GetLocationEv")]
            internal static extern global::System.IntPtr GetLocation_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue14GetLoadAddressEv")]
            internal static extern ulong GetLoadAddress_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue14GetNumChildrenEv")]
            internal static extern uint GetNumChildren_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("lldb", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN4lldb7SBValue13GetOpaqueTypeEv")]
            internal static extern global::System.IntPtr GetOpaqueType_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Value> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Value>();

        private readonly bool __ownsNativeInstance;

        public static Value __CreateInstance(global::System.IntPtr native)
        {
            return new Value((Value.Internal*) native);
        }

        public static Value __CreateInstance(Value.Internal native)
        {
            return new Value(native);
        }

        private static Value.Internal* __CopyValue(Value.Internal native)
        {
            var ret = (Value.Internal*) Marshal.AllocHGlobal(8);
            *ret = native;
            return ret;
        }

        private Value(Value.Internal native)
            : this(__CopyValue(native))
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Value(Value.Internal* native, bool isInternalImpl = false)
        {
            __Instance = new global::System.IntPtr(native);
        }

        public Value()
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            Internal.ctor_0(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        protected virtual void Dispose(bool disposing)
        {
            DestroyNativeInstance(false);
        }

        public virtual void DestroyNativeInstance()
        {
            DestroyNativeInstance(true);
        }

        private void DestroyNativeInstance(bool force)
        {
            LLDB.Value __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance || force)
                Internal.dtor_0(__Instance);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public bool IsValid()
        {
            var __ret = Internal.IsValid_0(__Instance);
            return __ret;
        }

        public void Clear()
        {
            Internal.Clear_0(__Instance);
        }

        public LLDB.Error GetError()
        {
            var __ret = new LLDB.Error.Internal();
            Internal.GetError_0(new IntPtr(&__ret), __Instance);
            return LLDB.Error.__CreateInstance(__ret);
        }

        public bool IsInScope()
        {
            var __ret = Internal.IsInScope_0(__Instance);
            return __ret;
        }

        public long GetValueAsSigned(LLDB.Error error, long fail_value)
        {
            var arg0 = ReferenceEquals(error, null) ? global::System.IntPtr.Zero : error.__Instance;
            var arg1 = fail_value;
            var __ret = Internal.GetValueAsSigned_0(__Instance, arg0, arg1);
            return __ret;
        }

        public ulong GetValueAsUnsigned(LLDB.Error error, ulong fail_value)
        {
            var arg0 = ReferenceEquals(error, null) ? global::System.IntPtr.Zero : error.__Instance;
            var arg1 = fail_value;
            var __ret = Internal.GetValueAsUnsigned_0(__Instance, arg0, arg1);
            return __ret;
        }

        public long GetValueAsSigned(long fail_value)
        {
            var arg0 = fail_value;
            var __ret = Internal.GetValueAsSigned_1(__Instance, arg0);
            return __ret;
        }

        public ulong GetValueAsUnsigned(ulong fail_value)
        {
            var arg0 = fail_value;
            var __ret = Internal.GetValueAsUnsigned_1(__Instance, arg0);
            return __ret;
        }

        public LLDB.Value GetDynamicValue(LLDB.DynamicValueType use_dynamic)
        {
            var arg0 = use_dynamic;
            var __ret = new LLDB.Value.Internal();
            Internal.GetDynamicValue_0(new IntPtr(&__ret), __Instance, arg0);
            return LLDB.Value.__CreateInstance(__ret);
        }

        public LLDB.Value GetStaticValue()
        {
            var __ret = new LLDB.Value.Internal();
            Internal.GetStaticValue_0(new IntPtr(&__ret), __Instance);
            return LLDB.Value.__CreateInstance(__ret);
        }

        public LLDB.Value GetNonSyntheticValue()
        {
            var __ret = new LLDB.Value.Internal();
            Internal.GetNonSyntheticValue_0(new IntPtr(&__ret), __Instance);
            return LLDB.Value.__CreateInstance(__ret);
        }

        public bool IsDynamic()
        {
            var __ret = Internal.IsDynamic_0(__Instance);
            return __ret;
        }

        public bool IsSynthetic()
        {
            var __ret = Internal.IsSynthetic_0(__Instance);
            return __ret;
        }

        public bool SetValueFromCString(string value_str)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(value_str);
            var __ret = Internal.SetValueFromCString_0(__Instance, arg0);
            Marshal.FreeHGlobal(arg0);
            return __ret;
        }

        public bool SetValueFromCString(string value_str, LLDB.Error error)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(value_str);
            var arg1 = ReferenceEquals(error, null) ? global::System.IntPtr.Zero : error.__Instance;
            var __ret = Internal.SetValueFromCString_1(__Instance, arg0, arg1);
            Marshal.FreeHGlobal(arg0);
            return __ret;
        }

        public LLDB.Value GetChildAtIndex(uint idx)
        {
            var arg0 = idx;
            var __ret = new LLDB.Value.Internal();
            Internal.GetChildAtIndex_0(new IntPtr(&__ret), __Instance, arg0);
            return LLDB.Value.__CreateInstance(__ret);
        }

        public LLDB.Value CreateChildAtOffset(string name, uint offset, LLDB.Type type)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var arg1 = offset;
            var arg2 = ReferenceEquals(type, null) ? new LLDB.Type.Internal() : *(LLDB.Type.Internal*) (type.__Instance);
            var __ret = new LLDB.Value.Internal();
            Internal.CreateChildAtOffset_0(new IntPtr(&__ret), __Instance, arg0, arg1, arg2);
            Marshal.FreeHGlobal(arg0);
            return LLDB.Value.__CreateInstance(__ret);
        }

        public LLDB.Value Cast(LLDB.Type type)
        {
            var arg0 = ReferenceEquals(type, null) ? new LLDB.Type.Internal() : *(LLDB.Type.Internal*) (type.__Instance);
            var __ret = new LLDB.Value.Internal();
            Internal.Cast_0(new IntPtr(&__ret), __Instance, arg0);
            return LLDB.Value.__CreateInstance(__ret);
        }

        public LLDB.Value CreateValueFromExpression(string name, string expression)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var arg1 = Marshal.StringToHGlobalAnsi(expression);
            var __ret = new LLDB.Value.Internal();
            Internal.CreateValueFromExpression_0(new IntPtr(&__ret), __Instance, arg0, arg1);
            Marshal.FreeHGlobal(arg0);
            Marshal.FreeHGlobal(arg1);
            return LLDB.Value.__CreateInstance(__ret);
        }

        public LLDB.Value CreateValueFromAddress(string name, ulong address, LLDB.Type type)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var arg1 = address;
            var arg2 = ReferenceEquals(type, null) ? new LLDB.Type.Internal() : *(LLDB.Type.Internal*) (type.__Instance);
            var __ret = new LLDB.Value.Internal();
            Internal.CreateValueFromAddress_0(new IntPtr(&__ret), __Instance, arg0, arg1, arg2);
            Marshal.FreeHGlobal(arg0);
            return LLDB.Value.__CreateInstance(__ret);
        }

        public LLDB.Value CreateValueFromData(string name, LLDB.Data data, LLDB.Type type)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var arg1 = ReferenceEquals(data, null) ? new LLDB.Data.Internal() : *(LLDB.Data.Internal*) (data.__Instance);
            var arg2 = ReferenceEquals(type, null) ? new LLDB.Type.Internal() : *(LLDB.Type.Internal*) (type.__Instance);
            var __ret = new LLDB.Value.Internal();
            Internal.CreateValueFromData_0(new IntPtr(&__ret), __Instance, arg0, arg1, arg2);
            Marshal.FreeHGlobal(arg0);
            return LLDB.Value.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Get a child value by index from a value.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// Get a child value by index from a value.</para>
        /// <para>    ///</para>
        /// <para>    /// Structs, unions, classes, arrays and pointers have
        /// child</para>
        /// <para>    /// values that can be access by index. </para>
        /// <para>    ///</para>
        /// <para>    /// Structs and unions access child members using a zero
        /// based index</para>
        /// <para>    /// for each child member. For</para>
        /// <para>    /// </para>
        /// <para>    /// Classes reserve the first indexes for base classes that
        /// have </para>
        /// <para>    /// members (empty base classes are omitted), and all members
        /// of the</para>
        /// <para>    /// current class will then follow the base classes. </para>
        /// <para>    ///</para>
        /// <para>    /// Pointers differ depending on what they point to. If the
        /// pointer</para>
        /// <para>    /// points to a simple type, the child at index zero</para>
        /// <para>    /// is the only child value available, unless \a
        /// synthetic_allowed </para>
        /// <para>    /// is \b true, in which case the pointer will be used as an
        /// array</para>
        /// <para>    /// and can create 'synthetic' child values using positive or
        /// </para>
        /// <para>    /// negative indexes. If the pointer points to an aggregate
        /// type </para>
        /// <para>    /// (an array, class, union, struct), then the pointee is
        /// </para>
        /// <para>    /// transparently skipped and any children are going to be
        /// the indexes</para>
        /// <para>    /// of the child values within the aggregate type. For
        /// example if</para>
        /// <para>    /// we have a 'Point' type and we have a SBValue that
        /// contains a</para>
        /// <para>    /// pointer to a 'Point' type, then the child at index zero
        /// will be</para>
        /// <para>    /// the 'x' member, and the child at index 1 will be the 'y'
        /// member</para>
        /// <para>    /// (the child at index zero won't be a 'Point'
        /// instance).</para>
        /// <para>    /// </para>
        /// <para>    /// Arrays have a preset number of children that can be
        /// accessed by</para>
        /// <para>    /// index and will returns invalid child values for indexes
        /// that are</para>
        /// <para>    /// out of bounds unless the \a synthetic_allowed is \b true.
        /// In this</para>
        /// <para>    /// case the array can create 'synthetic' child values for
        /// indexes </para>
        /// <para>    /// that aren't in the array bounds using positive or
        /// negative </para>
        /// <para>    /// indexes.</para>
        /// <para>    ///</para>
        /// <para>    /// @param[in] idx</para>
        /// <para>    ///     The index of the child value to get</para>
        /// <para>    ///</para>
        /// <para>    /// @param[in] use_dynamic</para>
        /// <para>    ///     An enumeration that specifies whether to get dynamic
        /// values,</para>
        /// <para>    ///     and also if the target can be run to figure out the
        /// dynamic</para>
        /// <para>    ///     type of the child value.</para>
        /// <para>    ///</para>
        /// <para>    /// @param[in] can_create_synthetic</para>
        /// <para>    ///     If \b true, then allow child values to be created by
        /// index</para>
        /// <para>    ///     for pointers and arrays for indexes that normally
        /// wouldn't</para>
        /// <para>    ///     be allowed.</para>
        /// <para>    ///</para>
        /// <para>    /// @return</para>
        /// <para>    ///     A new SBValue object that represents the child member
        /// value.</para>
        /// </remarks>
        public LLDB.Value GetChildAtIndex(uint idx, LLDB.DynamicValueType use_dynamic, bool can_create_synthetic)
        {
            var arg0 = idx;
            var arg1 = use_dynamic;
            var __ret = new LLDB.Value.Internal();
            Internal.GetChildAtIndex_1(new IntPtr(&__ret), __Instance, arg0, arg1, can_create_synthetic);
            return LLDB.Value.__CreateInstance(__ret);
        }

        public uint GetIndexOfChildWithName(string name)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var __ret = Internal.GetIndexOfChildWithName_0(__Instance, arg0);
            Marshal.FreeHGlobal(arg0);
            return __ret;
        }

        public LLDB.Value GetChildMemberWithName(string name)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var __ret = new LLDB.Value.Internal();
            Internal.GetChildMemberWithName_0(new IntPtr(&__ret), __Instance, arg0);
            Marshal.FreeHGlobal(arg0);
            return LLDB.Value.__CreateInstance(__ret);
        }

        public LLDB.Value GetChildMemberWithName(string name, LLDB.DynamicValueType use_dynamic)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(name);
            var arg1 = use_dynamic;
            var __ret = new LLDB.Value.Internal();
            Internal.GetChildMemberWithName_1(new IntPtr(&__ret), __Instance, arg0, arg1);
            Marshal.FreeHGlobal(arg0);
            return LLDB.Value.__CreateInstance(__ret);
        }

        public LLDB.Value GetValueForExpressionPath(string expr_path)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(expr_path);
            var __ret = new LLDB.Value.Internal();
            Internal.GetValueForExpressionPath_0(new IntPtr(&__ret), __Instance, arg0);
            Marshal.FreeHGlobal(arg0);
            return LLDB.Value.__CreateInstance(__ret);
        }

        public LLDB.Value AddressOf()
        {
            var __ret = new LLDB.Value.Internal();
            Internal.AddressOf_0(new IntPtr(&__ret), __Instance);
            return LLDB.Value.__CreateInstance(__ret);
        }

        public LLDB.Address GetAddress()
        {
            var __ret = new LLDB.Address.Internal();
            Internal.GetAddress_0(new IntPtr(&__ret), __Instance);
            return LLDB.Address.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Get an SBData wrapping what this SBValue points to.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// Get an SBData wrapping what this SBValue points to.</para>
        /// <para>    ///</para>
        /// <para>    /// This method will dereference the current SBValue, if
        /// its</para>
        /// <para>    /// data type is a T* or T[], and extract item_count
        /// elements</para>
        /// <para>    /// of type T from it, copying their contents in an SBData.
        /// </para>
        /// <para>    ///</para>
        /// <para>    /// @param[in] item_idx</para>
        /// <para>    ///     The index of the first item to retrieve. For an
        /// array</para>
        /// <para>    ///     this is equivalent to array[item_idx], for a
        /// pointer</para>
        /// <para>    ///     to *(pointer + item_idx). In either case, the
        /// measurement</para>
        /// <para>    ///     unit for item_idx is the sizeof(T) rather than the
        /// byte</para>
        /// <para>    ///</para>
        /// <para>    /// @param[in] item_count</para>
        /// <para>    ///     How many items should be copied into the output. By
        /// default</para>
        /// <para>    ///     only one item is copied, but more can be asked
        /// for.</para>
        /// <para>    ///</para>
        /// <para>    /// @return</para>
        /// <para>    ///     An SBData with the contents of the copied items, on
        /// success.</para>
        /// <para>    ///     An empty SBData otherwise.</para>
        /// </remarks>
        public LLDB.Data GetPointeeData(uint item_idx, uint item_count)
        {
            var arg0 = item_idx;
            var arg1 = item_count;
            var __ret = new LLDB.Data.Internal();
            Internal.GetPointeeData_0(new IntPtr(&__ret), __Instance, arg0, arg1);
            return LLDB.Data.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Get an SBData wrapping the contents of this SBValue.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// Get an SBData wrapping the contents of this SBValue.</para>
        /// <para>    ///</para>
        /// <para>    /// This method will read the contents of this object in
        /// memory</para>
        /// <para>    /// and copy them into an SBData for future use. </para>
        /// <para>    ///</para>
        /// <para>    /// @return</para>
        /// <para>    ///     An SBData with the contents of this SBValue, on
        /// success.</para>
        /// <para>    ///     An empty SBData otherwise.</para>
        /// </remarks>
        public LLDB.Data GetData()
        {
            var __ret = new LLDB.Data.Internal();
            Internal.GetData_0(new IntPtr(&__ret), __Instance);
            return LLDB.Data.__CreateInstance(__ret);
        }

        public bool SetData(LLDB.Data data, LLDB.Error error)
        {
            var arg0 = ReferenceEquals(data, null) ? global::System.IntPtr.Zero : data.__Instance;
            var arg1 = ReferenceEquals(error, null) ? global::System.IntPtr.Zero : error.__Instance;
            var __ret = Internal.SetData_0(__Instance, arg0, arg1);
            return __ret;
        }

        public LLDB.Declaration GetDeclaration()
        {
            var __ret = new LLDB.Declaration.Internal();
            Internal.GetDeclaration_0(new IntPtr(&__ret), __Instance);
            return LLDB.Declaration.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Find out if a SBValue might have children.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// Find out if a SBValue might have children.</para>
        /// <para>    ///</para>
        /// <para>    /// This call is much more efficient than GetNumChildren() as
        /// it</para>
        /// <para>    /// doesn't need to complete the underlying type. This is
        /// designed</para>
        /// <para>    /// to be used in a UI environment in order to detect if
        /// the</para>
        /// <para>    /// disclosure triangle should be displayed or not.</para>
        /// <para>    ///</para>
        /// <para>    /// This function returns true for class, union,
        /// structure,</para>
        /// <para>    /// pointers, references, arrays and more. Again, it does so
        /// without</para>
        /// <para>    /// doing any expensive type completion.</para>
        /// <para>    ///</para>
        /// <para>    /// @return</para>
        /// <para>    ///     Returns \b true if the SBValue might have children,
        /// or \b</para>
        /// <para>    ///     false otherwise.</para>
        /// </remarks>
        public bool MightHaveChildren()
        {
            var __ret = Internal.MightHaveChildren_0(__Instance);
            return __ret;
        }

        public bool IsRuntimeSupportValue()
        {
            var __ret = Internal.IsRuntimeSupportValue_0(__Instance);
            return __ret;
        }

        public LLDB.Target GetTarget()
        {
            var __ret = new LLDB.Target.Internal();
            Internal.GetTarget_0(new IntPtr(&__ret), __Instance);
            return LLDB.Target.__CreateInstance(__ret);
        }

        public LLDB.Process GetProcess()
        {
            var __ret = new LLDB.Process.Internal();
            Internal.GetProcess_0(new IntPtr(&__ret), __Instance);
            return LLDB.Process.__CreateInstance(__ret);
        }

        public LLDB.Thread GetThread()
        {
            var __ret = new LLDB.Thread.Internal();
            Internal.GetThread_0(new IntPtr(&__ret), __Instance);
            return LLDB.Thread.__CreateInstance(__ret);
        }

        public LLDB.Frame GetFrame()
        {
            var __ret = new LLDB.Frame.Internal();
            Internal.GetFrame_0(new IntPtr(&__ret), __Instance);
            return LLDB.Frame.__CreateInstance(__ret);
        }

        public LLDB.Value Dereference()
        {
            var __ret = new LLDB.Value.Internal();
            Internal.Dereference_0(new IntPtr(&__ret), __Instance);
            return LLDB.Value.__CreateInstance(__ret);
        }

        public bool TypeIsPointerType()
        {
            var __ret = Internal.TypeIsPointerType_0(__Instance);
            return __ret;
        }

        public LLDB.Type GetType()
        {
            var __ret = new LLDB.Type.Internal();
            Internal.GetType_0(new IntPtr(&__ret), __Instance);
            return LLDB.Type.__CreateInstance(__ret);
        }

        public LLDB.Value Persist()
        {
            var __ret = new LLDB.Value.Internal();
            Internal.Persist_0(new IntPtr(&__ret), __Instance);
            return LLDB.Value.__CreateInstance(__ret);
        }

        public bool GetDescription(LLDB.Stream description)
        {
            var arg0 = ReferenceEquals(description, null) ? global::System.IntPtr.Zero : description.__Instance;
            var __ret = Internal.GetDescription_0(__Instance, arg0);
            return __ret;
        }

        public bool GetExpressionPath(LLDB.Stream description)
        {
            var arg0 = ReferenceEquals(description, null) ? global::System.IntPtr.Zero : description.__Instance;
            var __ret = Internal.GetExpressionPath_0(__Instance, arg0);
            return __ret;
        }

        public bool GetExpressionPath(LLDB.Stream description, bool qualify_cxx_base_classes)
        {
            var arg0 = ReferenceEquals(description, null) ? global::System.IntPtr.Zero : description.__Instance;
            var __ret = Internal.GetExpressionPath_1(__Instance, arg0, qualify_cxx_base_classes);
            return __ret;
        }

        /// <summary>
        /// <para>Watch this value if it resides in memory.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// Watch this value if it resides in memory.</para>
        /// <para>    ///</para>
        /// <para>    /// Sets a watchpoint on the value.</para>
        /// <para>    ///</para>
        /// <para>    /// @param[in] resolve_location</para>
        /// <para>    ///     Resolve the location of this value once and watch its
        /// address.</para>
        /// <para>    ///     This value must currently be set to \b true as
        /// watching all</para>
        /// <para>    ///     locations of a variable or a variable path is not yet
        /// supported,</para>
        /// <para>    ///     though we plan to support it in the future.</para>
        /// <para>    ///</para>
        /// <para>    /// @param[in] read</para>
        /// <para>    ///     Stop when this value is accessed.</para>
        /// <para>    ///</para>
        /// <para>    /// @param[in] write</para>
        /// <para>    ///     Stop when this value is modified</para>
        /// <para>    ///</para>
        /// <para>    /// @param[out] error</para>
        /// <para>    ///     An error object. Contains the reason if there is some
        /// failure.</para>
        /// <para>    ///</para>
        /// <para>    /// @return</para>
        /// <para>    ///     An SBWatchpoint object. This object might not be
        /// valid upon</para>
        /// <para>    ///     return due to a value not being contained in memory,
        /// too </para>
        /// <para>    ///     large, or watchpoint resources are not available or
        /// all in</para>
        /// <para>    ///     use.</para>
        /// </remarks>
        public LLDB.Watchpoint Watch(bool resolve_location, bool read, bool write, LLDB.Error error)
        {
            var arg3 = ReferenceEquals(error, null) ? global::System.IntPtr.Zero : error.__Instance;
            var __ret = new LLDB.Watchpoint.Internal();
            Internal.Watch_0(new IntPtr(&__ret), __Instance, resolve_location, read, write, arg3);
            return LLDB.Watchpoint.__CreateInstance(__ret);
        }

        public LLDB.Watchpoint Watch(bool resolve_location, bool read, bool write)
        {
            var __ret = new LLDB.Watchpoint.Internal();
            Internal.Watch_1(new IntPtr(&__ret), __Instance, resolve_location, read, write);
            return LLDB.Watchpoint.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Watch this value that this value points to in memory</para>
        /// </summary>
        /// <remarks>
        /// <para>/// Watch this value that this value points to in memory</para>
        /// <para>    ///</para>
        /// <para>    /// Sets a watchpoint on the value.</para>
        /// <para>    ///</para>
        /// <para>    /// @param[in] resolve_location</para>
        /// <para>    ///     Resolve the location of this value once and watch its
        /// address.</para>
        /// <para>    ///     This value must currently be set to \b true as
        /// watching all</para>
        /// <para>    ///     locations of a variable or a variable path is not yet
        /// supported,</para>
        /// <para>    ///     though we plan to support it in the future.</para>
        /// <para>    ///</para>
        /// <para>    /// @param[in] read</para>
        /// <para>    ///     Stop when this value is accessed.</para>
        /// <para>    ///</para>
        /// <para>    /// @param[in] write</para>
        /// <para>    ///     Stop when this value is modified</para>
        /// <para>    ///</para>
        /// <para>    /// @param[out] error</para>
        /// <para>    ///     An error object. Contains the reason if there is some
        /// failure.</para>
        /// <para>    ///</para>
        /// <para>    /// @return</para>
        /// <para>    ///     An SBWatchpoint object. This object might not be
        /// valid upon</para>
        /// <para>    ///     return due to a value not being contained in memory,
        /// too </para>
        /// <para>    ///     large, or watchpoint resources are not available or
        /// all in</para>
        /// <para>    ///     use.</para>
        /// </remarks>
        public LLDB.Watchpoint WatchPointee(bool resolve_location, bool read, bool write, LLDB.Error error)
        {
            var arg3 = ReferenceEquals(error, null) ? global::System.IntPtr.Zero : error.__Instance;
            var __ret = new LLDB.Watchpoint.Internal();
            Internal.WatchPointee_0(new IntPtr(&__ret), __Instance, resolve_location, read, write, arg3);
            return LLDB.Watchpoint.__CreateInstance(__ret);
        }

        public ulong ID
        {
            get
            {
                var __ret = Internal.GetID_0(__Instance);
                return __ret;
            }
        }

        public string Name
        {
            get
            {
                var __ret = Internal.GetName_0(__Instance);
                return Marshal.PtrToStringAnsi(__ret);
            }
        }

        public string TypeName
        {
            get
            {
                var __ret = Internal.GetTypeName_0(__Instance);
                return Marshal.PtrToStringAnsi(__ret);
            }
        }

        public string DisplayTypeName
        {
            get
            {
                var __ret = Internal.GetDisplayTypeName_0(__Instance);
                return Marshal.PtrToStringAnsi(__ret);
            }
        }

        public uint ByteSize
        {
            get
            {
                var __ret = Internal.GetByteSize_0(__Instance);
                return __ret;
            }
        }

        public LLDB.Format Format
        {
            get
            {
                var __ret = Internal.GetFormat_0(__Instance);
                return __ret;
            }

            set
            {
                var arg0 = value;
                Internal.SetFormat_0(__Instance, arg0);
            }
        }

        public string ValueAsString
        {
            get
            {
                var __ret = Internal.GetValueAsString_0(__Instance);
                return Marshal.PtrToStringAnsi(__ret);
            }
        }

        public LLDB.ValueType ValueType
        {
            get
            {
                var __ret = Internal.GetValueType_0(__Instance);
                return __ret;
            }
        }

        public bool ValueDidChange
        {
            get
            {
                var __ret = Internal.GetValueDidChange_0(__Instance);
                return __ret;
            }
        }

        public string Summary
        {
            get
            {
                var __ret = Internal.GetSummary_0(__Instance);
                return Marshal.PtrToStringAnsi(__ret);
            }
        }

        public string ObjectDescription
        {
            get
            {
                var __ret = Internal.GetObjectDescription_0(__Instance);
                return Marshal.PtrToStringAnsi(__ret);
            }
        }

        public string TypeValidatorResult
        {
            get
            {
                var __ret = Internal.GetTypeValidatorResult_0(__Instance);
                return Marshal.PtrToStringAnsi(__ret);
            }
        }

        public LLDB.DynamicValueType PreferDynamicValue
        {
            get
            {
                var __ret = Internal.GetPreferDynamicValue_0(__Instance);
                return __ret;
            }

            set
            {
                var arg0 = value;
                Internal.SetPreferDynamicValue_0(__Instance, arg0);
            }
        }

        public bool PreferSyntheticValue
        {
            get
            {
                var __ret = Internal.GetPreferSyntheticValue_0(__Instance);
                return __ret;
            }

            set
            {
                Internal.SetPreferSyntheticValue_0(__Instance, value);
            }
        }

        public string Location
        {
            get
            {
                var __ret = Internal.GetLocation_0(__Instance);
                return Marshal.PtrToStringAnsi(__ret);
            }
        }

        public ulong LoadAddress
        {
            get
            {
                var __ret = Internal.GetLoadAddress_0(__Instance);
                return __ret;
            }
        }

        public uint NumChildren
        {
            get
            {
                var __ret = Internal.GetNumChildren_0(__Instance);
                return __ret;
            }
        }

        public global::System.IntPtr OpaqueType
        {
            get
            {
                var __ret = Internal.GetOpaqueType_0(__Instance);
                return __ret;
            }
        }
    }
}
